<!-- templates/shapefile_viewer.html -->
{% extends 'base.html' %} {% load static %} {% block content %}
<div class="app-container">
  <header>
    <div class="container-fluid">
      <div class="row align-items-center">
        <div class="col-md-6">
          <div class="logo">
            <i class="fas fa-globe-asia"></i>
            <h3 class="m-0">India GIS Vector Data Viewer</h3>
          </div>
        </div>
        <div class="col-md-6 text-end">
          <span class="text-light">Advanced Geospatial Analysis Tool</span>
        </div>
      </div>
    </div>
  </header>

  <div class="main-content">
    <div class="content-wrapper">
      <!-- Sidebar -->
      <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h5 class="m-0">Control Panel</h5>
        </div>

        <div class="control-section">
          <div class="section-title">
            <i class="fas fa-layer-group"></i> Feature Selection
          </div>
          <div class="modern-dropdown">
            <select id="categorySelect" class="custom-dropdown">
              <option value="" disabled selected>Select Category</option>
              <option value="administrative">Administrative</option>
              <option value="watershed">Watershed</option>
              <option value="rivers">Rivers</option>
              <option value="drains">Drains</option>
              <option value="canals">Canals</option>
              <option value="household">Household</option>
              <option value="roads">Roads</option>
              <option value="railways">Railways</option>
              <option value="industries">Industries</option>
              <option value="stps">STPs</option>
            </select>
          </div>

          <div class="modern-dropdown mt-3">
            <select id="subcategorySelect" class="custom-dropdown" disabled>
              <option value="" disabled selected>Select Subcategory</option>
            </select>
          </div>

          <button id="loadShapefile" class="btn-primary pulse-btn" disabled>
            <i class="fas fa-map-marked-alt"></i> Plot Features
          </button>
        </div>

        <div class="control-section">
          <div class="section-title">
            <i class="fas fa-map"></i> Map Options
          </div>

          <div class="modern-dropdown" id="basemap-dropdown">
            <div class="dropdown-header">
              <div><i class="fas fa-map"></i> Base Map</div>
              <i class="fas fa-chevron-down"></i>
            </div>
            <div class="dropdown-content">
              <div class="dropdown-item" data-basemap="streets">
                <i class="fas fa-road"></i> Streets
              </div>
              <div class="dropdown-item" data-basemap="satellite">
                <i class="fas fa-satellite"></i> Satellite
              </div>
              <div class="dropdown-item" data-basemap="terrain">
                <i class="fas fa-mountain"></i> Terrain
              </div>
              <div class="dropdown-item" data-basemap="traffic">
                <i class="fas fa-car"></i> Traffic
              </div>
              <div class="dropdown-item" data-basemap="hybrid">
                <i class="fas fa-globe"></i> Hybrid
              </div>
              <div class="dropdown-item" data-basemap="none">
                <i class="fas fa-ban"></i> No Basemap
              </div>
            </div>
          </div>

          <div class="modern-dropdown mt-3" id="drawing-dropdown">
            <div class="dropdown-header">
              <div><i class="fas fa-pencil-alt"></i> Drawing Tools</div>
              <i class="fas fa-chevron-down"></i>
            </div>
            <div class="dropdown-content">
              <div class="dropdown-item" data-tool="point">
                <i class="fas fa-map-marker-alt"></i> Add Point
              </div>
              <div class="dropdown-item" data-tool="line">
                <i class="fas fa-slash"></i> Draw Line
              </div>
              <div class="dropdown-item" data-tool="polygon">
                <i class="fas fa-draw-polygon"></i> Draw Polygon
              </div>
              <div class="dropdown-item" data-tool="measure">
                <i class="fas fa-ruler"></i> Measure
              </div>
              <div class="dropdown-item" data-tool="clear">
                <i class="fas fa-trash-alt"></i> Clear All
              </div>
            </div>
          </div>

          <div class="modern-dropdown mt-3" id="analysis-dropdown">
            <div class="dropdown-header">
              <div><i class="fas fa-chart-line"></i> Analysis Tools</div>
              <i class="fas fa-chevron-down"></i>
            </div>
            <div class="dropdown-content">
              <div class="dropdown-item" data-analysis="buffer">
                <i class="fas fa-expand-alt"></i> Buffer Zone
              </div>

              <div class="dropdown-item" data-analysis="intersect">
                <i class="fas fa-object-group"></i> Intersection
              </div>
              <div class="dropdown-item" data-analysis="dissolve">
                <i class="fas fa-object-ungroup"></i> Dissolve
              </div>
              <div class="dropdown-item" data-analysis="statistics">
                <i class="fas fa-calculator"></i> Statistics
              </div>
              <div class="dropdown-item" data-analysis="statistics">
                <i class="fas fa-calculator"></i> Eculadian Distance
              </div>
              <div class="dropdown-item" data-analysis="statistics">
                <i class="fas fa-calculator"></i> Union
              </div>
            </div>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">
            <i class="fas fa-palette"></i> Style Options
          </div>

          <div class="style-controls-container" style="display: flex; align-items: center; gap: 20px">
            <div class="style-control-item" style="display: flex; align-items: center">
              <label for="lineColor" class="form-label" style="margin-right: 8px">Line Color:</label>
              <input type="color" id="lineColor" class="color-input" value="#000000" />
            </div>

            <div class="style-control-item" style="display: flex; align-items: center">
              <label for="fillColor" class="form-label" style="margin-right: 8px">Fill Color:</label>
              <input type="color" id="fillColor" class="color-input" value="#78b4db" />
            </div>
          </div>
          <div class="style-control-row">
            <label for="opacity" class="form-label">Opacity: <span id="opacityValue">0.8</span></label>
            <input type="range" id="opacity" class="style-range" min="0.1" max="1" step="0.1" value="0.8" />
          </div>

          <div class="style-control-row">
            <label for="weight" class="form-label">Line Weight: <span id="weightValue">2</span></label>
            <input type="range" id="weight" class="style-range" min="1" max="10" step="1" value="2" />
          </div>

          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="toggleLabels" />
            <label class="form-check-label" for="toggleLabels">Show Labels</label>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">
            <i class="fas fa-sliders-h"></i> Display Settings
          </div>

          <div class="form-check form-switch mb-2">
            <input class="form-check-input" type="checkbox" id="grid-toggle" checked />
            <label class="form-check-label" for="grid-toggle">Coordinate Grid</label>
          </div>

          <div class="form-check form-switch mb-2">
            <input class="form-check-input" type="checkbox" id="info-toggle" checked />
            <label class="form-check-label" for="info-toggle">Show Info Panel</label>
          </div>

          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="compass-toggle" checked />
            <label class="form-check-label" for="compass-toggle">Show Compass</label>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">
            <i class="fas fa-file-export"></i> Export Options
          </div>

          <div class="export-container">
            <div class="form-group mb-2">
              <label for="mapTitle" class="form-label">Map Title:</label>
              <input type="text" id="mapTitle" class="custom-dropdown" placeholder="Enter title..." />
            </div>

            <div class="form-group mb-3">
              <label for="exportFormat" class="form-label">Export Format:</label>
              <select id="exportFormat" class="custom-dropdown">
                <option value="pdf">.pdf</option>
                <option value="svg">svg</option>
                <option value="jpg">.jpeg</option>
                <option value="tif">.tif</option>
              </select>
            </div>
            <div class="form-group">
              <label for="exportDPI">Export Quality (DPI):</label>
              <select id="exportDPI" class="form-control">
                <option value="1">Low (72 DPI)</option>
                <option value="2" selected>Medium (150 DPI)</option>
                <option value="3">High (300 DPI)</option>
                <option value="4">Ultra High (600 DPI)</option>
              </select>
            </div>
            <div class="form-group">
              <label for="exportLayout">Paper Layout:</label>
              <select id="exportLayout" class="form-control">
                <option value="a4-landscape" selected>A4 Landscape</option>
                <option value="a4-portrait">A4 Portrait</option>
                <option value="a3-landscape">A3 Landscape</option>
                <option value="a3-portrait">A3 Portrait</option>
                <option value="letter-landscape">Letter Landscape</option>
                <option value="letter-portrait">Letter Portrait</option>
                <option value="legal-landscape">Legal Landscape</option>
                <option value="legal-portrait">Legal Portrait</option>
              </select>
            </div>
            <button id="exportMap" class="btn-success">
              <i class="fas fa-download"></i> Export Map
            </button>
          </div>
        </div>
      </div>

      <button class="toggle-sidebar" id="toggle-sidebar">
        <i class="fas fa-chevron-left" id="toggle-icon"></i>
      </button>

      <!-- Map Container and Feature Info Panel in flexbox layout -->
      <div class="main-display-area">
        <div class="map-container">
          <div id="map"></div>




          <!-- Compass -->
          <div class="compass-container" id="compass">
            <div class="compass-rose">
              <div class="compass-ring"></div>
              <div class="compass-face"></div>
              <div class="compass-needle">
                <div class="needle-north"></div>
                <div class="needle-south"></div>
              </div>
              <div class="compass-center"></div>
              <div class="compass-cardinal-points">
                <span class="compass-n">N</span>
                <span class="compass-ne">NE</span>
                <span class="compass-e">E</span>
                <span class="compass-se">SE</span>
                <span class="compass-s">S</span>
                <span class="compass-sw">SW</span>
                <span class="compass-w">W</span>
                <span class="compass-nw">NW</span>
              </div>
              <div class="compass-degrees"></div>
            </div>
          </div>

          <!-- Download Button -->
          <button class="download-btn" id="download-btn">
            <i class="fas fa-download"></i> Download Shapefile
          </button>

          <!-- Map Controls -->
          <div class="map-controls">
            <button class="map-control-btn" id="zoom-in-btn" title="Zoom In">
              <i class="fas fa-plus"></i>
            </button>
            <button class="map-control-btn" id="zoom-out-btn" title="Zoom Out">
              <i class="fas fa-minus"></i>
            </button>
            <button class="map-control-btn" id="home-btn" title="Default View">
              <i class="fas fa-home"></i>
            </button>
            <button class="map-control-btn pulse-btn" id="locate-btn" title="My Location">
              <i class="fas fa-location-arrow"></i>
            </button>
            <button class="map-control-btn" id="fullscreen-btn" title="Fullscreen">
              <i class="fas fa-expand"></i>
            </button>
          </div>

          <!-- Coordinates Display -->
          <div id="coordinates">Latitude: 0, Longitude: 0</div>

          <!-- Loader -->
          <div class="loader" id="loader">
            <div class="d-flex align-items-center">
              <div class="spinner-border" role="status"></div>
              <span>Loading vector data...</span>
            </div>
          </div>
        </div>

        <!-- Feature Info Panel (now separated from map) -->
        <div class="feature-info-panel" id="feature-info">
          <div class="feature-info-header">
            <div class="feature-info-title">
              <i class="fas fa-info-circle"></i>
              <h5>Feature Information</h5>
            </div>
            <button class="feature-info-close" id="close-feature-info">
              <i class="fas fa-times"></i>
            </button>
          </div>
          <div id="feature-content">Select a feature to see details</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification">
    <div class="notification-header">
      <i class="fas fa-check-circle notification-icon"></i>
      <div class="notification-title">Success</div>
    </div>
    <div class="notification-body" id="notification-text">
      Vector data loaded successfully.
    </div>
  </div>
</div>

{% endblock %} {% block extra_css %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

<link rel="stylesheet" href="{% static 'css/mapplot.css' %}">

{% endblock %} {% block extra_js %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>

  // Global variables
  let map;
  let currentLayer = null;
  let activeFeature = null;
  let labelLayer = null;
  let labelsVisible = false;
  let gridLines = [];
  let mapRotation = 0;
  let baseLayers = {};

  // Category definitions
  const subcategories = {
    administrative: ["district", "villages"],
    watershed: ["varuna", "basuhi", "morwa", "all"],
    rivers: ["varuna", "basuhi", "morwa"],
    drains: ["varuna", "basuhi", "morwa"],
    canals: ["all"],
    household: [
      "All",
      "Bhadohi",
      "Jaunpur",
      "Pratapgarh",
      "Prayajraj",
      "Varanasi",
    ],
    roads: ["all"],
    railways: ["all"],
    industries: ["all"],
    stps: ["all"],
  };

  // Initialize map
  function initMap() {
    map = L.map("map", {
      zoomControl: false, // We'll add our own zoom controls
    }).setView([22.3511, 78.6677], 4); // Centered on India

    // Basemap Layers
    baseLayers = {
      streets: L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          maxZoom: 19,
        }
      ),

      satellite: L.tileLayer(
        "https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
        {
          subdomains: ["mt0", "mt1", "mt2", "mt3"],
          attribution:
            '&copy; <a href="https://www.google.com/maps">Google Maps</a>',
        }
      ),

      terrain: L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; <a href="https://opentopomap.org">OpenTopoMap</a>',
      }),

      traffic: L.tileLayer(
        "https://{s}.google.com/vt/lyrs=m@221097413,traffic&x={x}&y={y}&z={z}",
        {
          subdomains: ["mt0", "mt1", "mt2", "mt3"],
          attribution:
            '&copy; <a href="https://www.google.com/maps">Google Traffic</a>',
        }
      ),

      hybrid: L.layerGroup([
        L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            attribution:
              "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            maxZoom: 19,
          }
        ),
        L.tileLayer(
          "https://stamen-tiles-{s}.a.ssl.fastly.net/toner-labels/{z}/{x}/{y}{r}.png",
          {
            attribution:
              'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            subdomains: "abcd",
            maxZoom: 20,
            opacity: 0.7,
          }
        ),
      ]),

      none: L.tileLayer("", {
        attribution: "No basemap",
      }),
    };

    // Add default basemap
    baseLayers.traffic.addTo(map);

    // Add Scale Control
    L.control
      .scale({
        imperial: false,
        position: "bottomleft",
      })
      .addTo(map);

    // Initialize drawing tools
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
      position: "topright",
      draw: {
        polyline: {
          shapeOptions: {
            color: "#3498db",
            weight: 4,
          },
        },
        polygon: {
          allowIntersection: false,
          drawError: {
            color: "#e74c3c",
            timeout: 1000,
          },
          shapeOptions: {
            color: "#3498db",
          },
        },
        circle: {
          shapeOptions: {
            color: "#3498db",
          },
        },
        marker: true,
        rectangle: {
          shapeOptions: {
            color: "#3498db",
          },
        },
      },
      edit: {
        featureGroup: drawnItems,
      },
    });

    // Hover Event: Update Coordinates
    map.on("mousemove", function (e) {
      document.getElementById(
        "coordinates"
      ).innerHTML = `Lat: ${e.latlng.lat.toFixed(
        5
      )}, Long: ${e.latlng.lng.toFixed(5)}`;
    });

    // Initialize coordinate grid if enabled
    if (document.getElementById("grid-toggle").checked) {
      addCoordinateGrid();
    }

    // Handle drawing events
    map.on(L.Draw.Event.CREATED, function (event) {
      const layer = event.layer;
      drawnItems.addLayer(layer);

      // If it's a polygon, calculate area
      if (layer instanceof L.Polygon) {
        const latlngs = layer.getLatLngs()[0];

        // Calculate area (using simple formula for demo)
        let area = 0;
        for (let i = 0; i < latlngs.length; i++) {
          const j = (i + 1) % latlngs.length;
          area += latlngs[i].lng * latlngs[j].lat;
          area -= latlngs[j].lng * latlngs[i].lat;
        }
        area = Math.abs(area) * 0.5 * 111.32 * 111.32; // Rough conversion to square km

        layer
          .bindPopup(`<strong>Area:</strong> ${area.toFixed(2)} sq km`)
          .openPopup();
      }

      // If it's a polyline, calculate length
      if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        const latlngs = layer.getLatLngs();
        let length = 0;

        for (let i = 0; i < latlngs.length - 1; i++) {
          length += latlngs[i].distanceTo(latlngs[i + 1]);
        }

        layer
          .bindPopup(
            `<strong>Length:</strong> ${(length / 1000).toFixed(2)} km`
          )
          .openPopup();
      }

      // If it's a marker, show coordinates
      if (layer instanceof L.Marker) {
        const latLng = layer.getLatLng();
        layer
          .bindPopup(
            `<strong>Coordinates:</strong><br>Lat: ${latLng.lat.toFixed(
              5
            )}<br>Lng: ${latLng.lng.toFixed(5)}`
          )
          .openPopup();
      }

      showNotification(
        "Drawing Complete",
        "Your drawing has been added to the map",
        "success"
      );
    });
  }

  // Function to add coordinate grid lines
  function addCoordinateGrid() {
    // Clear previous grid lines
    gridLines.forEach((line) => {
      if (map.hasLayer(line)) {
        map.removeLayer(line);
      }
    });
    gridLines = [];

    // Latitude lines (every 5 degrees)
    for (let lat = 5; lat <= 40; lat += 5) {
      const line = L.polyline(
        [
          [lat, 65],
          [lat, 100],
        ],
        {
          color: "#3498db",
          weight: 1,
          opacity: 0.5,
          dashArray: "5,5",
        }
      ).addTo(map);

      const label = L.marker([lat, 65], {
        icon: L.divIcon({
          className: "coordinate-label",
          html: `${lat}°N`,
          iconSize: [40, 20],
          iconAnchor: [0, 10],
        }),
      }).addTo(map);

      gridLines.push(line, label);
    }

    // Longitude lines (every 5 degrees)
    for (let lng = 65; lng <= 100; lng += 5) {
      const line = L.polyline(
        [
          [5, lng],
          [40, lng],
        ],
        {
          color: "#3498db",
          weight: 1,
          opacity: 0.5,
          dashArray: "5,5",
        }
      ).addTo(map);

      const label = L.marker([5, lng], {
        icon: L.divIcon({
          className: "coordinate-label",
          html: `${lng}°E`,
          iconSize: [40, 20],
          iconAnchor: [20, -5],
        }),
      }).addTo(map);

      gridLines.push(line, label);
    }
  }

  // Function for showing notifications
  function showNotification(title, message, type = "success") {
    const notification = document.getElementById("notification");
    const notificationIcon = notification.querySelector(".notification-icon");
    const notificationTitle = notification.querySelector(".notification-title");
    const notificationText = document.getElementById("notification-text");

    // Set content
    notificationTitle.textContent = title;
    notificationText.textContent = message;

    // Set icon based on type
    if (type === "success") {
      notificationIcon.className = "fas fa-check-circle notification-icon";
      notificationIcon.style.color = "#2ecc71";
    } else if (type === "error") {
      notificationIcon.className =
        "fas fa-exclamation-circle notification-icon";
      notificationIcon.style.color = "#e74c3c";
    } else if (type === "info") {
      notificationIcon.className = "fas fa-info-circle notification-icon";
      notificationIcon.style.color = "#3498db";
    }

    // Show notification
    notification.classList.add("active");

    // Hide after 4 seconds
    setTimeout(() => {
      notification.classList.remove("active");
    }, 4000);
  }

  // Change basemap
  function changeBasemap(basemapId) {
    // Remove all current layers
    Object.values(baseLayers).forEach((layer) => {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    });

    // Add selected layer if it's not 'none'
    if (basemapId !== "none") {
      map.addLayer(baseLayers[basemapId]);
    }

    // Show notification
    const basemapName = basemapId.charAt(0).toUpperCase() + basemapId.slice(1);
    showNotification(
      "Basemap Changed",
      `Switched to ${basemapName} basemap`,
      "info"
    );
  }

  // Function to add labels to features
  function addLabels() {
    if (!currentLayer || labelLayer) return;

    labelLayer = L.layerGroup().addTo(map);

    currentLayer.eachLayer((layer) => {
      const feature = layer.feature;
      if (
        feature &&
        feature.properties &&
        (feature.geometry.type === "Polygon" ||
          feature.geometry.type === "MultiPolygon" ||
          feature.geometry.type === "LineString" ||
          feature.geometry.type === "MultiLineString")
      ) {
        const center = layer.getBounds().getCenter();
        const labelText =
          feature.properties.name ||
          feature.properties.NAME ||
          feature.properties.id ||
          feature.properties.ID ||
          "Unnamed";

        const label = L.divIcon({
          className: "map-label",
          html: `<div>${labelText}</div>`,
          iconSize: [100, 40],
          iconAnchor: [50, 20],
        });

        L.marker(center, {
          icon: label,
          zIndexOffset: 1000,
        }).addTo(labelLayer);
      }
    });
  }

  // Function to remove labels
  function removeLabels() {
    if (labelLayer) {
      map.removeLayer(labelLayer);
      labelLayer = null;
    }
  }

  // Function to toggle labels
  function toggleLabels(showLabels) {
    labelsVisible = showLabels;
    if (showLabels) {
      addLabels();
    } else {
      removeLabels();
    }
  }

  // Get current style settings
  function getCurrentStyle() {
    return {
      lineColor: document.getElementById("lineColor").value,
      fillColor: document.getElementById("fillColor").value,
      opacity: parseFloat(document.getElementById("opacity").value),
      weight: parseInt(document.getElementById("weight").value),
    };
  }

  // Update style display values
  function updateStyleDisplays() {
    document.getElementById("opacityValue").textContent =
      document.getElementById("opacity").value;
    document.getElementById("weightValue").textContent =
      document.getElementById("weight").value;
  }

  // Get style for feature
  function getFeatureStyle(feature, category) {
    const style = getCurrentStyle();

    // Special case for household category
    if (category === "household") {
      if (
        feature.geometry.type === "Polygon" ||
        feature.geometry.type === "MultiPolygon"
      ) {
        return {
          color: style.lineColor,
          fillColor: style.fillColor,
          weight: style.weight,
          opacity: 1,
          fillOpacity: style.opacity,
        };
      } else if (
        feature.geometry.type === "Point" ||
        feature.geometry.type === "MultiPoint"
      ) {
        return {
          radius: 6,
          fillColor: style.fillColor,
          color: style.lineColor,
          weight: Math.max(2, style.weight - 2),
          fillOpacity: style.opacity,
          opacity: 1,
        };
      } else if (
        feature.geometry.type === "LineString" ||
        feature.geometry.type === "MultiLineString"
      ) {
        return {
          color: style.lineColor,
          weight: style.weight,
          opacity: style.opacity,
          lineCap: "round",
          lineJoin: "round",
        };
      }
    }

    if (
      feature.geometry.type === "Polygon" ||
      feature.geometry.type === "MultiPolygon"
    ) {
      return {
        color: style.lineColor,
        fillColor: style.fillColor,
        weight: style.weight,
        opacity: 1,
        fillOpacity: style.opacity,
      };
    } else if (
      feature.geometry.type === "LineString" ||
      feature.geometry.type === "MultiLineString"
    ) {
      let baseStyle = {
        color: style.lineColor,
        weight: style.weight,
        opacity: style.opacity,
      };

      if (category === "railways") {
        baseStyle.dashArray = "15, 10";
      } else if (category === "rivers") {
        baseStyle.lineCap = "round";
        baseStyle.lineJoin = "round";
      } else if (category === "canals") {
        baseStyle.dashArray = "20, 10";
        baseStyle.lineCap = "round";
        baseStyle.lineJoin = "round";
      }

      return baseStyle;
    } else if (
      feature.geometry.type === "Point" ||
      feature.geometry.type === "MultiPoint"
    ) {
      return {
        radius: 8,
        fillColor: style.fillColor,
        color: style.lineColor,
        weight: style.weight,
        fillOpacity: style.opacity,
      };
    }
  }

  // Feature interaction handlers
  function highlightFeature(e) {
    const layer = e.target;
    const style = getCurrentStyle();

    layer.setStyle({
      weight: style.weight + 2,
      color: "#666",
      fillOpacity: Math.min(style.opacity + 0.2, 1),
    });

    layer.bringToFront();
    updateFeatureInfo(layer.feature.properties);
  }

  function resetHighlight(e) {
    // Only reset if this isn't the actively clicked feature
    if (!activeFeature || activeFeature !== e.target) {
      currentLayer.resetStyle(e.target);
    }
  }

  function handleFeatureClick(e) {
    const layer = e.target;
    updateFeatureInfo(layer.feature.properties);

    // Add active state styling
    layer.setStyle({
      weight: 3,
      color: "#ff4444",
      fillOpacity: 0.7,
    });

    // Remove active styling from previously clicked feature
    if (activeFeature && activeFeature !== layer) {
      currentLayer.resetStyle(activeFeature);
    }

    activeFeature = layer;
  }

  // Update feature info panel
  function updateFeatureInfo(properties) {
    if (!properties) {
      document.getElementById("feature-content").innerHTML =
        "Select a feature to see details";
      return;
    }

    // Create a formatted display of all properties
    let content = '<div class="feature-details">';
    for (const [key, value] of Object.entries(properties)) {
      content += `<p><strong>${key}:</strong> ${value}</p>`;
    }
    content += "</div>";

    document.getElementById("feature-content").innerHTML = content;
  }

  // Apply styles to current layer
  function applyStyles() {
    if (!currentLayer) return;

    const category = document.getElementById("categorySelect").value;
    currentLayer.eachLayer(function (layer) {
      layer.setStyle(getFeatureStyle(layer.feature, category));
    });

    // Reapply labels if enabled
    if (labelsVisible) {
      removeLabels();
      addLabels();
    }
  }

  // Update subcategories dropdown
  function updateSubcategories() {
    const category = document.getElementById("categorySelect").value;
    const subcategorySelect = document.getElementById("subcategorySelect");
    const loadButton = document.getElementById("loadShapefile");

    if (category) {
      subcategorySelect.innerHTML =
        '<option value="" disabled selected>Select Subcategory</option>';
      subcategories[category].forEach((sub) => {
        subcategorySelect.innerHTML += `<option value="${sub}">${sub.charAt(0).toUpperCase() + sub.slice(1)
          }</option>`;
      });
      subcategorySelect.disabled = false;
    } else {
      subcategorySelect.innerHTML =
        '<option value="" disabled selected>Select Subcategory</option>';
      subcategorySelect.disabled = true;
      loadButton.disabled = true;
    }
  }

  // Load shapefile data
  async function loadShapefile() {
    const category = document.getElementById("categorySelect").value;
    const subcategory = document.getElementById("subcategorySelect").value;
    const button = document.getElementById("loadShapefile");
    const style = getCurrentStyle();

    try {
      button.disabled = true;
      button.textContent = "Loading...";

      if (currentLayer) {
        map.removeLayer(currentLayer);
        currentLayer = null;
      }

      const url = `{% url "mapplot:get_data" %}?category=${category}&subcategory=${subcategory}`;
      const response = await fetch(url);
      const geojson = await response.json();

      if (!geojson.features || geojson.features.length === 0) {
        throw new Error("No feature data received");
      }

      currentLayer = L.geoJSON(geojson, {
        style: (feature) => getFeatureStyle(feature, category),
        onEachFeature: (feature, layer) => {
          layer.on({
            mouseover: highlightFeature,
            mouseout: resetHighlight,
            click: handleFeatureClick,
          });
        },
      }).addTo(map);

      map.fitBounds(currentLayer.getBounds());
    } catch (error) {
      console.error("Error loading shapefile:", error);
      alert("Failed to load shapefile: " + error.message);
    } finally {
      button.disabled = false;
      button.textContent = "Plot";
    }
  }
  // Create popup content from feature properties
  function createPopupContent(properties) {
    // Select up to 3 most important properties for popup display
    const priorityProps = [
      "name",
      "NAME",
      "id",
      "ID",
      "type",
      "TYPE",
      "description",
      "DESCRIPTION",
    ];
    let content = '<div class="popup-content">';
    let propsAdded = 0;

    // First add priority properties
    for (const prop of priorityProps) {
      if (properties[prop] && propsAdded < 3) {
        content += `<p><strong>${prop}:</strong> ${properties[prop]}</p>`;
        propsAdded++;
      }
    }

    // If we still need more properties, add others
    if (propsAdded < 3) {
      for (const [key, value] of Object.entries(properties)) {
        if (!priorityProps.includes(key) && propsAdded < 3) {
          content += `<p><strong>${key}:</strong> ${value}</p>`;
          propsAdded++;
        }
      }
    }

    content += "</div>";
    return content;
  }

  // Convert decimal coordinates to DMS format
  function decimalToDMS(decimal) {
    const degrees = Math.floor(Math.abs(decimal));
    const minutesDecimal = (Math.abs(decimal) - degrees) * 60;
    const minutes = Math.floor(minutesDecimal);
    const seconds = Math.floor((minutesDecimal - minutes) * 60);
    return {
      degrees: degrees,
      minutes: minutes,
      seconds: seconds,
      direction: decimal >= 0 ? 1 : -1,
    };
  }

  // Format DMS object to string
  function formatDMS(dms, isLatitude) {
    const direction = isLatitude
      ? dms.direction >= 0
        ? "N"
        : "S"
      : dms.direction >= 0
        ? "E"
        : "W";
    return `${dms.degrees}°${dms.minutes}'${dms.seconds}"${direction}`;
  }

  // Function to manually draw GeoJSON features onto the canvas
  function drawFeaturesOnCanvas(ctx, bounds, canvas, features, scaleFactor) {
    if (!features || !features.length) return;

    // Calculate the pixel coordinates from geographic coordinates
    function latLngToPixel(lat, lng) {
      const west = bounds.getWest();
      const east = bounds.getEast();
      const south = bounds.getSouth();
      const north = bounds.getNorth();

      // Calculate margins (same as in addCoordinatesToCanvas)
      const margin = {
        top: 60 * scaleFactor,
        bottom: 60 * scaleFactor,
        left: 60 * scaleFactor,
        right: 60 * scaleFactor,
      };

      // Available space for map
      const contentWidth = canvas.width - (margin.left + margin.right);
      const contentHeight = canvas.height - (margin.top + margin.bottom);

      // Convert lat/lng to x/y
      const x = margin.left + ((lng - west) / (east - west)) * contentWidth;
      const y = margin.top + ((north - lat) / (north - south)) * contentHeight;

      return { x, y };
    }

    // Set style for GeoJSON features
    ctx.lineWidth = 2 * scaleFactor;
    ctx.strokeStyle = "#000000";
    ctx.fillStyle = "rgba(53, 128, 255, 0.3)";

    // Loop through all features and draw them
    features.forEach(feature => {
      if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
        const coordinates = feature.geometry.type === "Polygon" ?
          [feature.geometry.coordinates] : feature.geometry.coordinates;

        coordinates.forEach(polygon => {
          polygon.forEach(ring => {
            ctx.beginPath();

            ring.forEach((coord, i) => {
              const pixel = latLngToPixel(coord[1], coord[0]);
              if (i === 0) {
                ctx.moveTo(pixel.x, pixel.y);
              } else {
                ctx.lineTo(pixel.x, pixel.y);
              }
            });

            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          });
        });
      } else if (feature.geometry.type === "LineString") {
        ctx.beginPath();
        feature.geometry.coordinates.forEach((coord, i) => {
          const pixel = latLngToPixel(coord[1], coord[0]);
          if (i === 0) {
            ctx.moveTo(pixel.x, pixel.y);
          } else {
            ctx.lineTo(pixel.x, pixel.y);
          }
        });
        ctx.stroke();
      } else if (feature.geometry.type === "Point") {
        const pixel = latLngToPixel(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
        ctx.beginPath();
        ctx.arc(pixel.x, pixel.y, 5 * scaleFactor, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }
    });
  }

  // Function to add coordinates to the canvas for image exports with DPI scaling
  function addCoordinatesToCanvas(canvas, bounds, scaleFactor = 1) {
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    // Extract bounds
    const west = parseFloat(bounds.getWest());
    const east = parseFloat(bounds.getEast());
    const south = parseFloat(bounds.getSouth());
    const north = parseFloat(bounds.getNorth());

    // Set styles for coordinate labels - adjust for DPI
    ctx.font = `${12 * scaleFactor}px Helvetica`;
    ctx.fillStyle = "#000000";
    ctx.textAlign = "center";

    // Margins for coordinate labels - increased to prevent overlap and scaled for DPI
    const margin = {
      top: 60 * scaleFactor,
      bottom: 60 * scaleFactor,
      left: 60 * scaleFactor,
      right: 60 * scaleFactor,
    };

    // Calculate available space for map
    const contentWidth = width - (margin.left + margin.right);
    const contentHeight = height - (margin.top + margin.bottom);

    // Draw coordinate scales
    const numDivisions = 5;

    // Draw white background for coordinates
    ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
    ctx.fillRect(0, 0, width, margin.top);
    ctx.fillRect(0, height - margin.bottom, width, margin.bottom);
    ctx.fillRect(0, 0, margin.left, height);
    ctx.fillRect(width - margin.right, 0, margin.right, height);

    ctx.fillStyle = "#000000";

    // Draw border around map area first (so coordinates can overlay if needed)
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 2 * scaleFactor;
    ctx.strokeRect(margin.left, margin.top, contentWidth, contentHeight);

    // Latitude scales (left and right)
    for (let i = 0; i <= numDivisions; i++) {
      const lat = south + ((north - south) * i) / numDivisions;
      const yPos =
        margin.top + (contentHeight * (numDivisions - i)) / numDivisions;
      const dms = decimalToDMS(lat);
      const label = formatDMS(dms, true);

      // Left side
      ctx.save();
      ctx.translate(margin.left - (18 * scaleFactor), yPos);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(label, 0, 0);
      ctx.restore();

      // Right side
      ctx.save();
      ctx.translate(width - margin.right + (18 * scaleFactor), yPos);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(label, 0, 0);
      ctx.restore();

      // Draw tick marks
      ctx.beginPath();
      ctx.moveTo(margin.left - (5 * scaleFactor), yPos);
      ctx.lineTo(margin.left, yPos);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(width - margin.right, yPos);
      ctx.lineTo(width - margin.right + (5 * scaleFactor), yPos);
      ctx.stroke();
    }

    // Longitude scales (top and bottom)
    for (let i = 0; i <= numDivisions; i++) {
      const lon = west + ((east - west) * i) / numDivisions;
      const xPos = margin.left + (contentWidth * i) / numDivisions;
      const dms = decimalToDMS(lon);
      const label = formatDMS(dms, false);

      // Top side
      ctx.fillText(label, xPos, margin.top - (18 * scaleFactor));

      // Bottom side
      ctx.fillText(label, xPos, height - margin.bottom + (25 * scaleFactor));

      // Draw tick marks
      ctx.beginPath();
      ctx.moveTo(xPos, margin.top - (5 * scaleFactor));
      ctx.lineTo(xPos, margin.top);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(xPos, height - margin.bottom);
      ctx.lineTo(xPos, height - margin.bottom + (5 * scaleFactor));
      ctx.stroke();
    }

    // Add compass directions
    ctx.font = `bold ${14 * scaleFactor}px Helvetica`;
    ctx.fillText("N", width / 2, margin.top - (35 * scaleFactor));
    ctx.fillText("S", width / 2, height - margin.bottom + (40 * scaleFactor));
    ctx.fillText("W", margin.left - (35 * scaleFactor), height / 2);
    ctx.fillText("E", width - margin.right + (35 * scaleFactor), height / 2);

    return canvas;
  }

  // Function to draw GeoJSON features with their original styles - improved for clarity and positioning
  function drawFeaturesWithStyles(ctx, bounds, canvas, featuresWithStyles, scaleFactor) {
    if (!featuresWithStyles || !featuresWithStyles.length) return;

    // Calculate the pixel coordinates from geographic coordinates with high precision
    function latLngToPixel(lat, lng) {
      const west = bounds.getWest();
      const east = bounds.getEast();
      const south = bounds.getSouth();
      const north = bounds.getNorth();

      // Calculate margins (same as in addCoordinatesToCanvas)
      const margin = {
        top: 60 * scaleFactor,
        bottom: 60 * scaleFactor,
        left: 60 * scaleFactor,
        right: 60 * scaleFactor,
      };

      // Available space for map
      const contentWidth = canvas.width - (margin.left + margin.right);
      const contentHeight = canvas.height - (margin.top + margin.bottom);

      // We need to compensate for the different vertical scaling between Leaflet and our canvas
      // This dynamically calculates an adjustment based on the map's actual dimensions
      const aspectRatio = (north - south) / (east - west);
      const canvasAspectRatio = contentHeight / contentWidth;

      // Dynamically calculate adjustment instead of using a fixed factor
      const adjustmentFactor = Math.max(0, (aspectRatio / canvasAspectRatio - 1) * 0.05);

      // Precise conversion from lat/lng to x/y with a better adjustment
      const x = margin.left + ((lng - west) / (east - west)) * contentWidth;
      const y = margin.top + ((north - lat) / (north - south)) * contentHeight * (1 - adjustmentFactor);

      return { x: Math.round(x), y: Math.round(y) };
    }
    // Enable crisp edges for lines
    ctx.imageSmoothingEnabled = false;

    // Loop through all features and draw them with their original styles
    featuresWithStyles.forEach(item => {
      const feature = item.feature;
      const style = item.style;

      // Set style based on the original layer style
      ctx.lineWidth = Math.max(1, Math.round(style.weight * scaleFactor)); // Ensure minimum line width of 1px
      ctx.strokeStyle = style.color;
      ctx.fillStyle = style.fillColor;

      if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
        const coordinates = feature.geometry.type === "Polygon" ?
          [feature.geometry.coordinates] : feature.geometry.coordinates;

        coordinates.forEach(polygon => {
          polygon.forEach(ring => {
            ctx.beginPath();

            ring.forEach((coord, i) => {
              const pixel = latLngToPixel(coord[1], coord[0]);
              if (i === 0) {
                ctx.moveTo(pixel.x, pixel.y);
              } else {
                ctx.lineTo(pixel.x, pixel.y);
              }
            });

            ctx.closePath();

            // Set fill with proper opacity
            ctx.globalAlpha = style.fillOpacity;
            ctx.fill();

            // Set stroke with proper opacity
            ctx.globalAlpha = style.opacity;
            ctx.stroke();

            // Reset alpha
            ctx.globalAlpha = 1.0;
          });
        });
      } else if (feature.geometry.type === "LineString" || feature.geometry.type === "MultiLineString") {
        ctx.globalAlpha = style.opacity;

        if (feature.geometry.type === "LineString") {
          ctx.beginPath();
          feature.geometry.coordinates.forEach((coord, i) => {
            const pixel = latLngToPixel(coord[1], coord[0]);
            if (i === 0) {
              ctx.moveTo(pixel.x, pixel.y);
            } else {
              ctx.lineTo(pixel.x, pixel.y);
            }
          });
          ctx.stroke();
        } else {
          // Handle MultiLineString
          feature.geometry.coordinates.forEach(line => {
            ctx.beginPath();
            line.forEach((coord, i) => {
              const pixel = latLngToPixel(coord[1], coord[0]);
              if (i === 0) {
                ctx.moveTo(pixel.x, pixel.y);
              } else {
                ctx.lineTo(pixel.x, pixel.y);
              }
            });
            ctx.stroke();
          });
        }

        // Reset alpha
        ctx.globalAlpha = 1.0;
      } else if (feature.geometry.type === "Point" || feature.geometry.type === "MultiPoint") {
        const coordinates = feature.geometry.type === "Point" ?
          [feature.geometry.coordinates] : feature.geometry.coordinates;

        coordinates.forEach(coord => {
          const pixel = latLngToPixel(coord[1], coord[0]);

          // Fill
          ctx.globalAlpha = style.fillOpacity;
          ctx.beginPath();
          ctx.arc(pixel.x, pixel.y, Math.max(3, style.weight * scaleFactor), 0, 2 * Math.PI);
          ctx.fill();

          // Stroke
          ctx.globalAlpha = style.opacity;
          ctx.stroke();

          // Reset alpha
          ctx.globalAlpha = 1.0;
        });
      }
    });

    // Reset image smoothing
    ctx.imageSmoothingEnabled = true;
  }

  function exportAsPDF(mapImage, mapTitle, category, subcategory, timestamp, dpi, featuresWithStyles = [], bounds) {
  // Get the selected layout
  const layoutOption = document.getElementById("exportLayout").value;
  
  // Split the layout option into format and orientation
  const [format, orientation] = layoutOption.split('-');
  
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({
    orientation: orientation,
    unit: "mm",
    format: format,
    compress: false // Disable compression for better quality
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();

  // Margins for coordinate labels
  const margin = {
    top: 25,
    bottom: 25,
    left: 25,
    right: 25,
  };

  // Calculate available space for map
  const contentWidth = pageWidth - (margin.left + margin.right);
  const contentHeight = pageHeight - (margin.top + margin.bottom);

  // Add title with adjusted position
  pdf.setFont("helvetica", "bold");
  pdf.setFontSize(24);
  pdf.text(mapTitle, pageWidth / 2, 15, { align: "center" });

  const img = new Image();
  img.src = mapImage;
  img.onload = function () {
    const imgWidth = img.width;
    const imgHeight = img.height;

    // Calculate dimensions to fit
    let newWidth = contentWidth - 20;
    let newHeight = (imgHeight * newWidth) / imgWidth;

    // Check if height exceeds available space
    if (newHeight > contentHeight - 20) {
      newHeight = contentHeight - 20;
      newWidth = (imgWidth * newHeight) / imgHeight;
    }

    // Center the map in the available space
    const xPos = margin.left + (contentWidth - newWidth) / 2;
    const yPos = margin.top + (contentHeight - newHeight) / 2;

    // For sharper rendering in PDF: 
    // Use a single high-resolution canvas for all drawing
    const pdfCanvas = document.createElement('canvas');
    
    // Create a canvas with higher resolution for sharper output
    // Scale based on the user-selected DPI, with a minimum multiplier of 3
    const canvasScale = Math.max(3, dpi / 96);
    pdfCanvas.width = imgWidth * canvasScale;
    pdfCanvas.height = imgHeight * canvasScale;
    
    const pdfCtx = pdfCanvas.getContext('2d');
    
    // Apply sharp rendering settings
    pdfCtx.imageSmoothingEnabled = false;
    
    // First draw the base map (scaled up for quality)
    pdfCtx.drawImage(img, 0, 0, pdfCanvas.width, pdfCanvas.height);
    
    // Draw features with proper geo-positioning and original styles
    if (featuresWithStyles && featuresWithStyles.length > 0) {
      // Calculate the proper scale factor based on user DPI
      const pdfScaleFactor = canvasScale;
      
      // Draw directly onto the high-resolution PDF canvas
      drawFeaturesWithStyles(
        pdfCtx, 
        bounds, 
        pdfCanvas, 
        featuresWithStyles, 
        pdfScaleFactor
      );
    }
    
    // Get the high-quality image
    const pdfMapImage = pdfCanvas.toDataURL('image/png', 1.0);
    
    // Draw border around map area
    pdf.setDrawColor(0);
    pdf.setLineWidth(0.5);
    pdf.rect(xPos - 5, yPos - 5, newWidth + 10, newHeight + 10);
    
    // Add the map image with features using the FAST alias for better quality
    pdf.addImage(pdfMapImage, "PNG", xPos, yPos, newWidth, newHeight, undefined, 'FAST');

    // Add coordinate scales on all four sides
    addCoordinateScales(pdf, xPos, yPos, newWidth, newHeight);

    // Add metadata to bottom with proper spacing
    const textYPos = pageHeight - 15;
    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(10);
    
    // Adjust metadata position based on page size
    const metadataSpacing = pageWidth < 210 ? 40 : 60;
    
    pdf.text(`Category: ${category}`, margin.left, textYPos);
    pdf.text(`Subcategory: ${subcategory}`, margin.left + metadataSpacing, textYPos);
    pdf.text(`Generated: ${timestamp}`, margin.left + (metadataSpacing * 2), textYPos);
    
    // For smaller page formats, we might need to adjust or omit some metadata
    if (pageWidth >= 210) {
      pdf.text(`Source: IIT BHU DSS (${dpi} DPI)`, margin.left + (metadataSpacing * 3), textYPos);
    }

    // Save PDF with format in filename
    pdf.save(`${mapTitle.replace(/\s+/g, "_")}_${format}_${orientation}.pdf`);

    showNotification(
      "Export Complete",
      `Map exported as PDF successfully (${format.toUpperCase()} ${orientation}, ${dpi} DPI)`,
      "success"
    );
  };
}
  function handleMapExport() {
    const mapElement = document.getElementById("map");
    const exportFormat = document.getElementById("exportFormat").value;
    const exportDPI = parseInt(document.getElementById("exportDPI").value);
    const mapTitle =
      document.getElementById("mapTitle").value || "India GIS Vector Map";

    const categorySelect = document.getElementById("categorySelect");
    const subcategorySelect = document.getElementById("subcategorySelect");
    const selectedCategory =
      categorySelect.options[categorySelect.selectedIndex]?.text ||
      "No Category Selected";
    const selectedSubcategory =
      subcategorySelect.options[subcategorySelect.selectedIndex]?.text ||
      "No Subcategory Selected";
    const timestamp = new Date().toLocaleString();

    showNotification("Exporting", "Preparing map export...", "info");

    // Ensure map is properly sized and fully rendered
    map.invalidateSize(true);

    // Get map dimensions
    const mapWidth = mapElement.clientWidth;
    const mapHeight = mapElement.clientHeight;

    // Calculate base size (uncompressed) at 72 DPI
    const basePixelCount = mapWidth * mapHeight;
    const baseImageSize = basePixelCount * 4; // Size in bytes at 72 DPI (RGBA)

    // Estimate target DPI based on selected quality level
    const MIN_TARGET_SIZE = 500 * 1024;
    const MAX_TARGET_SIZE = 10 * 1024 * 1024;
    const estimatedCompressionRatio = 0.25;

    // Calculate DPI values for min/max file sizes
    const maxDPI = Math.sqrt(MAX_TARGET_SIZE / (baseImageSize * estimatedCompressionRatio)) * 72;
    const minDPI = Math.sqrt(MIN_TARGET_SIZE / (baseImageSize * estimatedCompressionRatio)) * 72;

    // Convert exportDPI value to actual DPI
    let dpi;
    switch (exportDPI) {
      case 1: // Low
        dpi = Math.max(72, Math.min(minDPI, 100));
        break;
      case 2: // Medium
        dpi = Math.min(Math.max(minDPI, 150), Math.min(300, maxDPI));
        break;
      case 3: // High
        dpi = Math.min(Math.max(200, minDPI), Math.min(400, maxDPI));
        break;
      case 4: // Ultra High
        dpi = Math.min(Math.max(300, minDPI), maxDPI);
        break;
      default:
        dpi = 150; // Medium as default
    }

    // Cap the DPI to reasonable values
    dpi = Math.max(72, Math.min(dpi, 600));

    console.log(`Map dimensions: ${mapWidth}x${mapHeight}, Calculated DPI: ${dpi.toFixed(0)}`);

    // Set scale factor based on DPI
    const scaleFactor = dpi / 96;

    // Wait for map to stabilize - longer delay to ensure complete rendering
    setTimeout(async () => {
      try {
        // Get the bounds before html2canvas
        const bounds = map.getBounds();

        // Log the bounds for debugging - this helps identify positioning issues
        console.log("Export using bounds:",
          `North: ${bounds.getNorth().toFixed(6)}`,
          `South: ${bounds.getSouth().toFixed(6)}`,
          `East: ${bounds.getEast().toFixed(6)}`,
          `West: ${bounds.getWest().toFixed(6)}`
        );

        // Create a fixed bounds object to ensure consistency across all functions
        // Create a more complete bounds object
        const exportBounds = {
          getNorth: () => bounds.getNorth(),
          getSouth: () => bounds.getSouth(),
          getEast: () => bounds.getEast(),
          getWest: () => bounds.getWest(),
          getNorthWest: () => L.latLng(bounds.getNorth(), bounds.getWest()),
          getNorthEast: () => L.latLng(bounds.getNorth(), bounds.getEast()),
          getSouthWest: () => L.latLng(bounds.getSouth(), bounds.getWest()),
          getSouthEast: () => L.latLng(bounds.getSouth(), bounds.getEast())
        };

        // Collect all GeoJSON features with their styles
        let featuresWithStyles = [];

        // Store visibility state of layers
        let layerVisibility = {};

        if (currentLayer) {
          currentLayer.eachLayer(layer => {
            if (layer.feature) {
              // Store layer visibility
              layerVisibility[layer._leaflet_id] = map.hasLayer(layer);

              // Store feature with its style
              const style = layer.options || {};
              featuresWithStyles.push({
                feature: layer.feature,
                style: {
                  fillColor: style.fillColor || "#3388ff",
                  color: style.color || "#3388ff",
                  weight: style.weight || 3,
                  opacity: style.opacity || 1.0,
                  fillOpacity: style.fillOpacity || 0.2
                }
              });

              // Hide the layer temporarily to avoid duplication
              if (map.hasLayer(layer)) {
                map.removeLayer(layer);
              }
            }
          });
        }

        // Capture the map base without GeoJSON layers
        const mapCanvas = await html2canvas(mapElement, {
          useCORS: true,
          allowTaint: true,
          scale: scaleFactor * 1.5, // Higher scale factor for better quality
          backgroundColor: "#ffffff",
          logging: false,
          removeContainer: false,
          imageTimeout: 0, // No timeout for images
          onclone: function (clonedDoc) {
            // Use this to ensure the cloned document has fully-loaded tiles
            const mapPane = clonedDoc.querySelector('.leaflet-map-pane');
            if (mapPane) {
              mapPane.style.willChange = 'transform'; // Better rendering
            }
          }
        });

        // Restore layer visibility
        if (currentLayer) {
          currentLayer.eachLayer(layer => {
            if (layer.feature && layerVisibility[layer._leaflet_id]) {
              map.addLayer(layer);
            }
          });
        }

        // Create a larger canvas for final output
        const finalCanvas = document.createElement('canvas');
        const padding = 120 * scaleFactor;
        finalCanvas.width = mapCanvas.width + padding * 2;
        finalCanvas.height = mapCanvas.height + padding * 2;

        // Apply CSS for better rendering quality
        finalCanvas.style.imageRendering = '-webkit-optimize-contrast';
        finalCanvas.style.imageRendering = 'crisp-edges';

        // Draw white background and base map
        const ctx = finalCanvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
        ctx.drawImage(mapCanvas, padding, padding);

        // Draw the features with proper geographic positioning and original styles
        drawFeaturesWithStyles(ctx, exportBounds, finalCanvas, featuresWithStyles, scaleFactor);

        // For image formats (PNG/JPG)
        if (exportFormat === 'png' || exportFormat === 'jpg') {
          // Add title to the canvas
          ctx.font = `bold ${24 * scaleFactor}px Helvetica`;
          ctx.fillStyle = '#000000';
          ctx.textAlign = 'center';
          ctx.fillText(mapTitle, finalCanvas.width / 2, padding / 2);

          // Add metadata to the canvas
          ctx.font = `${12 * scaleFactor}px Helvetica`;
          ctx.textAlign = 'left';
          ctx.fillText(`Category: ${selectedCategory}`, padding, finalCanvas.height - padding / 2 + (5 * scaleFactor));
          ctx.fillText(`Subcategory: ${selectedSubcategory}`, padding + (180 * scaleFactor), finalCanvas.height - padding / 2 + (5 * scaleFactor));
          ctx.fillText(`Generated: ${timestamp}`, padding + (360 * scaleFactor), finalCanvas.height - padding / 2 + (5 * scaleFactor));
          ctx.textAlign = 'right';
          ctx.fillText(`Source: IIT BHU DSS`, finalCanvas.width - padding, finalCanvas.height - padding / 2 + (5 * scaleFactor));

          // Add the coordinates to the canvas
          addCoordinatesToCanvas(finalCanvas, exportBounds, scaleFactor);

          // Get the final image
          const finalImage = finalCanvas.toDataURL(`image/${exportFormat === 'jpg' ? 'jpeg' : 'png'}`, 1.0);

          // Download the image
          const link = document.createElement("a");
          link.download = `${mapTitle.replace(/\s+/g, "_")}.${exportFormat}`;
          link.href = finalImage;
          link.click();

          showNotification(
            "Export Complete",
            `Map exported as ${exportFormat.toUpperCase()} successfully at ${dpi} DPI`,
            "success"
          );
        }
        // For PDF export
        else if (exportFormat === 'pdf') {
          // Get map image for PDF
          const mapImage = mapCanvas.toDataURL("image/png", 1.0);

          // Use the improved exportAsPDF function with featuresWithStyles
          exportAsPDF(
            mapImage,
            mapTitle,
            selectedCategory,
            selectedSubcategory,
            timestamp,
            dpi,
            featuresWithStyles,
            exportBounds
          );
        }
        // For SVG format
        else if (exportFormat === 'svg') {
          // Add title to the canvas
          ctx.font = `bold ${24 * scaleFactor}px Helvetica`;
          ctx.fillStyle = '#000000';
          ctx.textAlign = 'center';
          ctx.fillText(mapTitle, finalCanvas.width / 2, padding / 2);

          // Add metadata to the canvas
          ctx.font = `${12 * scaleFactor}px Helvetica`;
          ctx.textAlign = 'left';
          ctx.fillText(`Category: ${selectedCategory}`, padding, finalCanvas.height - padding / 2 + (5 * scaleFactor));
          ctx.fillText(`Subcategory: ${selectedSubcategory}`, padding + (180 * scaleFactor), finalCanvas.height - padding / 2 + (5 * scaleFactor));
          ctx.fillText(`Generated: ${timestamp}`, padding + (360 * scaleFactor), finalCanvas.height - padding / 2 + (5 * scaleFactor));
          ctx.textAlign = 'right';
          ctx.fillText(`Source: IIT BHU DSS`, finalCanvas.width - padding, finalCanvas.height - padding / 2 + (5 * scaleFactor));

          // Add coordinates
          addCoordinatesToCanvas(finalCanvas, exportBounds, scaleFactor);

          // Convert to SVG
          const svgData = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${finalCanvas.width}" height="${finalCanvas.height}">
          <image href="${finalCanvas.toDataURL('image/png')}" width="${finalCanvas.width}" height="${finalCanvas.height}" />
        </svg>
        `;

          // Create SVG Blob and download
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const svgUrl = URL.createObjectURL(svgBlob);

          const link = document.createElement("a");
          link.download = `${mapTitle.replace(/\s+/g, "_")}.svg`;
          link.href = svgUrl;
          link.click();

          // Clean up
          URL.revokeObjectURL(svgUrl);

          showNotification(
            "Export Complete",
            `Map exported as SVG successfully at ${dpi} DPI`,
            "success"
          );
        }
        else if (exportFormat === 'tif') {
          showNotification(
            "Notice",
            "TIFF export will be implemented in a future update",
            "info"
          );
        }
      } catch (error) {
        console.error("Error exporting map:", error);
        showNotification(
          "Error",
          "Failed to export map: " + error.message,
          "error"
        );
      }
    }, 1500); // Longer timeout for more reliable capture
  }

  // Add coordinate scales to PDF
  function addCoordinateScales(pdf, x, y, width, height) {
    const bounds = map.getBounds();
    const west = parseFloat(bounds.getWest());
    const east = parseFloat(bounds.getEast());
    const south = parseFloat(bounds.getSouth());
    const north = parseFloat(bounds.getNorth());

    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(8);

    // Draw coordinate labels on all four sides
    const numDivisions = 5;

    // Latitude scales (left and right)
    for (let i = 0; i <= numDivisions; i++) {
      const lat = south + ((north - south) * i) / numDivisions;
      const yPos = y + (height * (numDivisions - i)) / numDivisions;
      const dms = decimalToDMS(lat);
      const label = formatDMS(dms, true);

      // Left side - vertical text with better alignment
      pdf.saveGraphicsState();
      pdf.text(label, x - 2, yPos + 5, {
        align: "center",
        angle: 90,
      });
      pdf.restoreGraphicsState();

      // Right side - vertical text with better alignment
      pdf.saveGraphicsState();
      pdf.text(label, x + width + 17, yPos + 5, {
        align: "center",
        angle: 90,
      });
      pdf.restoreGraphicsState();

      // Draw tick marks
      pdf.line(x - 2, yPos, x, yPos);
      pdf.line(x + width, yPos, x + width + 2, yPos);
    }

    // Longitude scales (top and bottom)
    for (let i = 0; i <= numDivisions; i++) {
      const lon = west + ((east - west) * i) / numDivisions;
      const xPos = x + (width * i) / numDivisions;
      const dms = decimalToDMS(lon);
      const label = formatDMS(dms, false);

      // Top side - properly centered
      pdf.text(label, xPos, y - 7, {
        align: "center",
      });

      // Bottom side - properly centered
      pdf.text(label, xPos, y + height + 12, {
        align: "center",
      });

      // Draw tick marks
      pdf.line(xPos, y - 2, xPos, y);
      pdf.line(xPos, y + height, xPos, y + height + 2);
    }

    // Add compass directions
    pdf.setFont("helvetica", "bold");
    pdf.setFontSize(10);
    pdf.text("N", x + width / 2, y - 15, { align: "center" });
    pdf.text("S", x + width / 2, y + height + 20, { align: "center" });
    pdf.text("W", x - 15, y + height / 2, { align: "center" });
    pdf.text("E", x + width + 15, y + height / 2, { align: "center" });
  }


  // Document ready function
  document.addEventListener("DOMContentLoaded", function () {
    // Initialize map
    initMap();
    updateStyleDisplays();

    // Add event listeners for controls

    // Category selection
    document
      .getElementById("categorySelect")
      .addEventListener("change", updateSubcategories);

    document
      .getElementById("subcategorySelect")
      .addEventListener("change", function () {
        document.getElementById("loadShapefile").disabled = !this.value;
      });

    // Map data loading
    document
      .getElementById("loadShapefile")
      .addEventListener("click", loadShapefile);

    // Style control event listeners
    document.getElementById("opacity").addEventListener("input", function () {
      document.getElementById("opacityValue").textContent = this.value;
      applyStyles();
    });

    document.getElementById("weight").addEventListener("input", function () {
      document.getElementById("weightValue").textContent = this.value;
      applyStyles();
    });

    document.getElementById("lineColor").addEventListener("input", applyStyles);
    document.getElementById("fillColor").addEventListener("input", applyStyles);

    // Label toggle
    document
      .getElementById("toggleLabels")
      .addEventListener("change", function (e) {
        toggleLabels(e.target.checked);
      });

    // Grid toggle
    document
      .getElementById("grid-toggle")
      .addEventListener("change", function (e) {
        if (e.target.checked) {
          addCoordinateGrid();
        } else {
          gridLines.forEach((line) => {
            if (map.hasLayer(line)) {
              map.removeLayer(line);
            }
          });
          gridLines = [];
        }
      });

    // Info panel toggle
    document
      .getElementById("info-toggle")
      .addEventListener("change", function (e) {
        document.getElementById("feature-info").style.display = e.target.checked
          ? "block"
          : "none";
      });

    // Compass toggle
    document
      .getElementById("compass-toggle")
      .addEventListener("change", function (e) {
        document.getElementById("compass").style.display = e.target.checked
          ? "flex"
          : "none";
      });

    // Feature info panel close button
    document
      .getElementById("close-feature-info")
      .addEventListener("click", function () {
        document.getElementById("info-toggle").checked = false;
        document.getElementById("feature-info").style.display = "none";
      });

    // Toggle sidebar
    document
      .getElementById("toggle-sidebar")
      .addEventListener("click", function () {
        const sidebar = document.getElementById("sidebar");
        const toggleBtn = document.getElementById("toggle-sidebar");
        const toggleIcon = document.getElementById("toggle-icon");

        sidebar.classList.toggle("collapsed");
        toggleBtn.classList.toggle("collapsed");

        if (sidebar.classList.contains("collapsed")) {
          toggleIcon.className = "fas fa-chevron-right";
        } else {
          toggleIcon.className = "fas fa-chevron-left";
        }

        // Update map size after sidebar toggle
        setTimeout(() => {
          map.invalidateSize();
        }, 300);
      });

    // Export map
    document
      .getElementById("exportMap")
      .addEventListener("click", handleMapExport);

    // Map control buttons
    document
      .getElementById("zoom-in-btn")
      .addEventListener("click", function () {
        map.zoomIn(1);
      });

    document
      .getElementById("zoom-out-btn")
      .addEventListener("click", function () {
        map.zoomOut(1);
      });

    document.getElementById("home-btn").addEventListener("click", function () {
      map.setView([22.3511, 78.6677], 4);
      showNotification("Map Reset", "Returned to default view", "info");
    });

    document
      .getElementById("locate-btn")
      .addEventListener("click", function () {
        showNotification("Location", "Finding your location...", "info");

        map
          .locate({ setView: true, maxZoom: 16 })
          .on("locationfound", function (e) {
            // Add a marker at the location
            const locationMarker = L.circleMarker(e.latlng, {
              radius: 8,
              color: "#3498db",
              weight: 3,
              opacity: 1,
              fillColor: "#3498db",
              fillOpacity: 0.4,
            }).addTo(map);

            // Add a pulsing circle
            const pulseCircle = L.circleMarker(e.latlng, {
              radius: 0,
              color: "#3498db",
              weight: 3,
              opacity: 0,
              fillColor: "#3498db",
              fillOpacity: 0.2,
            }).addTo(map);

            // Animate the pulse
            let radius = 0;
            const pulseAnimation = setInterval(() => {
              radius += 1;
              pulseCircle.setRadius(radius);
              pulseCircle.setStyle({
                opacity: Math.max(0, 1 - radius / 30),
                fillOpacity: Math.max(0, 0.2 - radius / 30),
              });

              if (radius > 30) {
                radius = 0;
              }
            }, 50);

            // Clear animation after 5 seconds
            setTimeout(() => {
              clearInterval(pulseAnimation);
              map.removeLayer(pulseCircle);
            }, 5000);

            showNotification(
              "Location Found",
              "Your current location has been located",
              "success"
            );
          })
          .on("locationerror", function (e) {
            // Fallback for demo or if geolocation fails
            const randomLat = 22.3511 + (Math.random() * 2 - 1);
            const randomLng = 78.6677 + (Math.random() * 2 - 1);
            map.setView([randomLat, randomLng], 10);

            L.marker([randomLat, randomLng])
              .addTo(map)
              .bindPopup("Simulated location (Geolocation not available)")
              .openPopup();

            showNotification(
              "Location Simulated",
              "Using demo location (geolocation unavailable)",
              "info"
            );
          });
      });

    document
      .getElementById("fullscreen-btn")
      .addEventListener("click", function () {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch((err) => {
            showNotification(
              "Error",
              `Fullscreen failed: ${err.message}`,
              "error"
            );
          });
          this.innerHTML = '<i class="fas fa-compress"></i>';
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
            this.innerHTML = '<i class="fas fa-expand"></i>';
          }
        }
      });

    // Download shapefile button
    document
      .getElementById("download-btn")
      .addEventListener("click", function () {
        const category = document.getElementById("categorySelect").value;
        const subcategory = document.getElementById("subcategorySelect").value;

        if (!category || !subcategory) {
          showNotification(
            "Error",
            "Please select a category and subcategory first",
            "error"
          );
          return;
        }

        const originalText = this.innerHTML;
        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing...';
        this.disabled = true;

        // Simulate download process (replace with actual download implementation)
        setTimeout(() => {
          const link = document.createElement("a");
          link.href = `download_data/?category=${category}&subcategory=${subcategory}`;
          link.download = `${category}_${subcategory}.zip`;
          link.click();

          this.innerHTML = originalText;
          this.disabled = false;

          showNotification(
            "Download Started",
            `Shapefile for ${category} - ${subcategory} is being downloaded`,
            "success"
          );
        }, 1500);
      });

    // Handle basemap dropdown interactions
    document
      .querySelectorAll("#basemap-dropdown .dropdown-item")
      .forEach((item) => {
        item.addEventListener("click", function () {
          const basemapType = this.getAttribute("data-basemap");
          changeBasemap(basemapType);

          // Close dropdown
          document
            .querySelector("#basemap-dropdown .dropdown-content")
            .classList.remove("show");
          document
            .querySelector("#basemap-dropdown .dropdown-header")
            .classList.remove("active");
        });
      });

    // Handle drawing tools dropdown items
    document
      .querySelectorAll("#drawing-dropdown .dropdown-item")
      .forEach((item) => {
        item.addEventListener("click", function () {
          const toolType = this.getAttribute("data-tool");

          switch (toolType) {
            case "point":
              new L.Draw.Marker(map).enable();
              showNotification("Drawing Tool", "Point tool activated", "info");
              break;
            case "line":
              new L.Draw.Polyline(map).enable();
              showNotification("Drawing Tool", "Line tool activated", "info");
              break;
            case "polygon":
              new L.Draw.Polygon(map).enable();
              showNotification(
                "Drawing Tool",
                "Polygon tool activated",
                "info"
              );
              break;
            case "measure":
              new L.Draw.Polyline(map, {
                shapeOptions: {
                  color: "#ff7800",
                  weight: 3,
                },
              }).enable();
              showNotification(
                "Measurement Tool",
                "Draw a line to measure distance",
                "info"
              );
              break;
            case "clear":
              map.eachLayer((layer) => {
                if (layer instanceof L.Marker || layer instanceof L.Path) {
                  if (layer !== currentLayer && !layer._layers) {
                    map.removeLayer(layer);
                  }
                }
              });
              showNotification(
                "Cleared",
                "All drawings have been cleared",
                "info"
              );
              break;
          }

          // Close dropdown
          document
            .querySelector("#drawing-dropdown .dropdown-content")
            .classList.remove("show");
          document
            .querySelector("#drawing-dropdown .dropdown-header")
            .classList.remove("active");
        });
      });

    // Handle analysis tools
    document
      .querySelectorAll("#analysis-dropdown .dropdown-item")
      .forEach((item) => {
        item.addEventListener("click", function () {
          const analysisType = this.getAttribute("data-analysis");

          // Show notification for demo
          showNotification(
            "Analysis Tool",
            `${analysisType.charAt(0).toUpperCase() + analysisType.slice(1)
            } analysis tool selected`,
            "info"
          );

          // Close dropdown
          document
            .querySelector("#analysis-dropdown .dropdown-content")
            .classList.remove("show");
          document
            .querySelector("#analysis-dropdown .dropdown-header")
            .classList.remove("active");
        });
      });
    //////////////////////////////////////////////////////////////////////////////////
    // Buffer Tool Fix - Implementation to ensure toolbar appears

    // Enhanced Buffer Tools Implementation
    document.addEventListener('DOMContentLoaded', function () {
      // Create style for buffer toolbar
      addBufferToolbarStyles();

      // Create and add the buffer toolbar to the DOM
      createAndAddBufferToolbar();

      // Modify analysis dropdown handler
      modifyAnalysisDropdownHandler();

      // Load Turf.js for buffer operations
      ensureTurfJsLoaded();
    });

    // Function to add required styles
    function addBufferToolbarStyles() {
      const styleElement = document.createElement('style');
      styleElement.id = 'buffer-tool-styles';
      styleElement.textContent = `
    .thin-strip-toolbar {
      display: none; /* Initially hidden */
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 5px;
      position: absolute;
      top: 60px;
      left: 10px;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .buffer-tool-btn {
      width: 30px;
      height: 30px;
      margin: 0 3px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 3px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .buffer-tool-btn:hover {
      background-color: #f0f0f0;
    }

    .buffer-tool-btn.active {
      background-color: #e0e0e0;
      border-color: #999;
    }

    .buffer-tool-btn[data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 12px;
      white-space: nowrap;
    }
    
    .buffer-button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 5px;
      width: 100%;
    }
    
    .buffer-button:hover {
      background-color: #2980b9;
    }
    
    .buffer-info {
      padding: 5px;
    }
  `;

      document.head.appendChild(styleElement);
    }

    // Create and add buffer toolbar to DOM
    function createAndAddBufferToolbar() {
      // Create toolbar container
      const bufferToolbar = document.createElement('div');
      bufferToolbar.id = 'buffer-toolbar';
      bufferToolbar.className = 'thin-strip-toolbar';

      // Create toolbar title
      const toolbarTitle = document.createElement('div');
      toolbarTitle.className = 'toolbar-title';
      toolbarTitle.style.marginRight = '10px';
      toolbarTitle.style.fontWeight = 'bold';
      toolbarTitle.textContent = 'Buffer:';
      bufferToolbar.appendChild(toolbarTitle);

      // Add buffer drawing tools
      const tools = [
        { id: 'buffer-point', icon: 'fas fa-map-marker-alt', tooltip: 'Place Point' },
        { id: 'buffer-line', icon: 'fas fa-slash', tooltip: 'Draw Line' },
        { id: 'buffer-polygon', icon: 'fas fa-draw-polygon', tooltip: 'Draw Polygon' }
      ];

      tools.forEach(tool => {
        const toolButton = document.createElement('button');
        toolButton.id = tool.id;
        toolButton.className = 'buffer-tool-btn';
        toolButton.setAttribute('data-tooltip', tool.tooltip);

        // Add icon
        const icon = document.createElement('i');
        icon.className = tool.icon;
        toolButton.appendChild(icon);

        // Add click event listener
        toolButton.addEventListener('click', function () {
          activateBufferTool(tool.id);
        });

        bufferToolbar.appendChild(toolButton);
      });

      // Add close button
      const closeButton = document.createElement('button');
      closeButton.className = 'buffer-tool-btn';
      closeButton.setAttribute('data-tooltip', 'Close Buffer Tool');
      closeButton.style.marginLeft = '10px';

      const closeIcon = document.createElement('i');
      closeIcon.className = 'fas fa-times';
      closeButton.appendChild(closeIcon);

      closeButton.addEventListener('click', function () {
        bufferToolbar.style.display = 'none';
      });

      bufferToolbar.appendChild(closeButton);

      // Add the toolbar to the map container
      document.addEventListener('DOMContentLoaded', function () {
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.appendChild(bufferToolbar);
        } else {
          document.body.appendChild(bufferToolbar);
        }
      });
    }

    // Modify analysis dropdown handler
    function modifyAnalysisDropdownHandler() {
      document.addEventListener('DOMContentLoaded', function () {
        // Wait for the page to fully load
        setTimeout(() => {
          // Find all analysis dropdown items
          document.querySelectorAll("#analysis-dropdown .dropdown-item").forEach((item) => {
            // Remove any existing click listeners (to avoid duplicates)
            const oldItem = item.cloneNode(true);
            item.parentNode.replaceChild(oldItem, item);

            // Add our new click listener
            oldItem.addEventListener("click", function () {
              const analysisType = this.getAttribute("data-analysis");

              // Special handling for buffer tool
              if (analysisType === 'buffer') {
                // Show buffer toolbar
                const bufferToolbar = document.getElementById('buffer-toolbar');
                if (bufferToolbar) {
                  bufferToolbar.style.display = 'flex';

                  showNotification(
                    "Buffer Tool",
                    "Buffer tool selected. Choose a drawing method.",
                    "info"
                  );
                } else {
                  showNotification(
                    "Error",
                    "Buffer toolbar not found. Please refresh the page.",
                    "error"
                  );
                }
              } else {
                // Hide buffer toolbar for other tools
                const bufferToolbar = document.getElementById('buffer-toolbar');
                if (bufferToolbar) {
                  bufferToolbar.style.display = 'none';
                }

                showNotification(
                  "Analysis Tool",
                  `${analysisType.charAt(0).toUpperCase() + analysisType.slice(1)} analysis tool selected`,
                  "info"
                );
              }

              // Close dropdown
              document
                .querySelector("#analysis-dropdown .dropdown-content")
                .classList.remove("show");
              document
                .querySelector("#analysis-dropdown .dropdown-header")
                .classList.remove("active");
            });
          });
        }, 500); // Short delay to ensure elements are fully loaded
      });
    }

    // Function to handle buffer tool activation
    function activateBufferTool(toolId) {
      // Deactivate all tools first
      document.querySelectorAll('.buffer-tool-btn').forEach(btn => {
        btn.classList.remove('active');
      });

      // Activate the selected tool
      document.getElementById(toolId).classList.add('active');

      // Set the current active tool and apply appropriate action
      const toolType = toolId.split('-')[1]; // Extract 'polygon', 'point', or 'line'

      showNotification(
        "Buffer Tool",
        `${toolType.charAt(0).toUpperCase() + toolType.slice(1)} tool activated`,
        "info"
      );

      // Setup appropriate drawing method based on the selected tool
      switch (toolType) {
        case 'point':
          setupBufferPointTool();
          break;
        case 'line':
          setupBufferLineTool();
          break;
        case 'polygon':
          setupBufferPolygonTool();
          break;
      }
    }

    // Setup buffer point drawing tool
    function setupBufferPointTool() {
      // Use Leaflet.draw for point placement
      new L.Draw.Marker(map, {
        icon: new L.Icon({
          iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
          shadowSize: [41, 41]
        })
      }).enable();

      // If we don't already have a created event handler for buffer features
      if (!map._hasBufferCreateHandler) {
        map._hasBufferCreateHandler = true;

        // Store the original handler if it exists
        const originalCreatedHandler = map._events['draw:created'] ? [...map._events['draw:created']] : [];

        // Add our custom handler for buffer features
        map.on('draw:created', function (e) {
          const type = e.layerType;
          const layer = e.layer;

          // Add the layer to the map
          layer.addTo(map);

          // Special handling for buffer features
          if (document.getElementById('buffer-toolbar').style.display === 'flex') {
            // It's a buffer feature - add special popup
            if (type === 'marker') {
              // Point buffer
              layer.bindPopup(createBufferControlsPopup('Point')).openPopup();
            } else if (type === 'polyline') {
              // Line buffer
              layer.bindPopup(createBufferControlsPopup('Line')).openPopup();
            } else if (type === 'polygon') {
              // Polygon buffer
              layer.bindPopup(createBufferControlsPopup('Polygon')).openPopup();
            }

            // Setup buffer controls event handlers
            layer.on('popupopen', setupBufferControlsHandlers);
          } else {
            // It's a regular feature - call original handlers
            if (originalCreatedHandler.length > 0) {
              originalCreatedHandler.forEach(handler => {
                handler.fn.call(handler.ctx, e);
              });
            }
          }
        });
      }
    }

    // Setup buffer line drawing tool
    function setupBufferLineTool() {
      // Use Leaflet.draw for line drawing
      new L.Draw.Polyline(map, {
        shapeOptions: {
          color: document.getElementById('lineColor')?.value || 'red',
          weight: parseInt(document.getElementById('weight')?.value || 3)
        }
      }).enable();
    }

    // Setup buffer polygon drawing tool
    function setupBufferPolygonTool() {
      // Use Leaflet.draw for polygon drawing
      new L.Draw.Polygon(map, {
        shapeOptions: {
          color: document.getElementById('lineColor')?.value || '#3498db',
          fillColor: document.getElementById('fillColor')?.value || '#3498db',
          fillOpacity: parseFloat(document.getElementById('opacity')?.value || 0.5),
          weight: parseInt(document.getElementById('weight')?.value || 3)
        }
      }).enable();
    }

    // Create popup content with buffer controls
    function createBufferControlsPopup(featureType) {
      return `
    <div class="buffer-info">
      <h4>Buffer ${featureType}</h4>
      <p>To create a buffer zone around this ${featureType.toLowerCase()}, adjust the distance:</p>
      <div class="buffer-controls">
        <label>Buffer Distance (meters): <span id="buffer-distance-value">500</span></label>
        <input type="range" id="buffer-distance" min="100" max="10000" value="500" step="100" />
        <button id="apply-buffer" class="buffer-button">Apply Buffer</button>
      </div>
    </div>
  `;
    }

    // Setup event handlers for buffer controls in popup
    function setupBufferControlsHandlers() {
      const slider = document.getElementById('buffer-distance');
      const valueDisplay = document.getElementById('buffer-distance-value');
      const applyButton = document.getElementById('apply-buffer');

      if (slider && valueDisplay && applyButton) {
        // Update display value when slider changes
        slider.addEventListener('input', function () {
          valueDisplay.textContent = this.value;
        });

        // Apply buffer when button is clicked
        applyButton.addEventListener('click', () => {
          const layer = this._source || this; // Get the layer (this context may vary)
          const distance = parseInt(slider.value);

          if (distance > 0) {
            // Create the buffer
            createBufferZone(layer, distance);

            // Close the popup
            layer.closePopup();

            // Hide the buffer toolbar after operation is complete
            const bufferToolbar = document.getElementById('buffer-toolbar');
            if (bufferToolbar) {
              bufferToolbar.style.display = 'none';
            }
          }
        });
      }
    }

    // Apply buffer to a feature
    function createBufferZone(sourceFeature, distance) {
      if (!map) {
        console.error("Map not initialized");
        return;
      }

      if (typeof turf === 'undefined') {
        showNotification(
          "Error",
          "Buffer functionality requires Turf.js library which is not loaded",
          "error"
        );
        ensureTurfJsLoaded();
        return;
      }

      try {
        // Convert Leaflet feature to GeoJSON
        const featureGeoJSON = sourceFeature.toGeoJSON();

        // Use turf.js to create buffer
        const buffered = turf.buffer(featureGeoJSON, distance / 1000, { units: 'kilometers' });

        // Add the buffer to the map
        const bufferLayer = L.geoJSON(buffered, {
          style: {
            color: '#ff7800',
            weight: 2,
            opacity: 0.8,
            fillColor: '#ff7800',
            fillOpacity: 0.2
          }
        }).addTo(map);

        // Add popup with buffer info
        bufferLayer.bindPopup(`
      <div class="buffer-info">
        <h4>Buffer Zone</h4>
        <p>Distance: ${distance} meters</p>
        <p>Source: ${sourceFeature instanceof L.Polygon ? 'Polygon' :
            sourceFeature instanceof L.Marker ? 'Point' :
              'Line'}</p>
      </div>
    `);

        showNotification(
          "Buffer Created",
          `${distance}m buffer zone has been applied`,
          "success"
        );

        return bufferLayer;
      } catch (error) {
        console.error("Error creating buffer:", error);
        showNotification(
          "Error",
          "Failed to create buffer: " + error.message,
          "error"
        );
      }
    }

    // Add Turf.js script if not already loaded
    function ensureTurfJsLoaded() {
      if (typeof turf === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/@turf/turf@6/turf.min.js';
        script.onload = function () {
          console.log("Turf.js library loaded successfully");
        };
        script.onerror = function () {
          console.error("Failed to load Turf.js library");
        };
        document.head.appendChild(script);
      }
    }
    /////////////////////////////////////////////////////////////////////////////////////
    // Toggle modern dropdowns
    document.querySelectorAll(".dropdown-header").forEach((header) => {
      header.addEventListener("click", function () {
        const content = this.nextElementSibling;
        const allContents = document.querySelectorAll(".dropdown-content");
        const allHeaders = document.querySelectorAll(".dropdown-header");

        // Close all other dropdowns
        allContents.forEach((item) => {
          if (item !== content) {
            item.classList.remove("show");
          }
        });

        allHeaders.forEach((item) => {
          if (item !== this) {
            item.classList.remove("active");
          }
        });

        // Toggle current dropdown
        content.classList.toggle("show");
        this.classList.toggle("active");
      });
    });

    // Click outside to close dropdowns
    document.addEventListener("click", function (event) {
      const dropdowns = document.querySelectorAll(".modern-dropdown");
      let clickedOutside = true;

      dropdowns.forEach((dropdown) => {
        if (dropdown.contains(event.target)) {
          clickedOutside = false;
        }
      });

      if (clickedOutside) {
        document.querySelectorAll(".dropdown-content").forEach((content) => {
          content.classList.remove("show");
        });

        document.querySelectorAll(".dropdown-header").forEach((header) => {
          header.classList.remove("active");
        });
      }
    });

    // Adjust for mobile screens on load
    function adjustForScreenSize() {
      if (window.innerWidth <= 768) {
        const sidebar = document.getElementById("sidebar");
        const toggleBtn = document.getElementById("toggle-sidebar");
        sidebar.classList.add("collapsed");
        toggleBtn.classList.add("collapsed");
        document.getElementById("toggle-icon").className =
          "fas fa-chevron-right";
      }
    }

    // Check screen size on load
    adjustForScreenSize();

    // Update when window is resized
    window.addEventListener("resize", adjustForScreenSize);
  });

  //////////////////////////////
  // Add this code at the very end of your script tag, OUTSIDE your existing DOMContentLoaded handler

  // Create the buffer toolbar and functionality after the page is fully loaded
  window.addEventListener('load', function () {
    // Create buffer toolbar
    const bufferToolbar = document.createElement('div');
    bufferToolbar.id = 'buffer-toolbar';
    bufferToolbar.className = 'thin-strip-toolbar';
    bufferToolbar.style.cssText = `
    display: none;
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    position: absolute;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    flex-direction: row;
    align-items: center;
  `;

    // Create the toolbar content with buffer distance slider
    bufferToolbar.innerHTML = `
    <div style="font-weight:bold; margin-right:10px;">Buffer Tools:</div>
    
    <div style="display:flex; align-items:center; margin-right:15px;">
      <span>Buffer Distance: </span>
      <span id="buffer-value" style="min-width:40px; text-align:center;">1</span>
      <span> km</span>
    </div>
    
    <div style="margin-right:15px; min-width:150px;">
      <input type="range" id="buffer-distance" min="0.1" max="200" value="1" step="0.1" style="width:100%;" />
    </div>
    
    <button id="buffer-point" class="map-control-btn" title="Place Point (Circle)"><i class="fas fa-circle"></i></button>
    <button id="buffer-line" class="map-control-btn" title="Draw Line with Width"><i class="fas fa-road"></i></button>
    <button id="buffer-polygon" class="map-control-btn" title="Draw Buffered Polygon"><i class="fas fa-draw-polygon"></i></button>
    <button id="buffer-clear" class="map-control-btn" title="Clear All Buffers"><i class="fas fa-trash-alt"></i></button>
    <button id="buffer-close" class="map-control-btn" title="Close"><i class="fas fa-times"></i></button>
  `;

    // Add to map container
    document.querySelector('.map-container').appendChild(bufferToolbar);

    // Load Turf.js if needed
    if (typeof turf === 'undefined') {
      const script = document.createElement('script');
      script.src = 'https://unpkg.com/@turf/turf@6/turf.min.js';
      document.head.appendChild(script);
    }

    // Create a feature group to hold all buffer layers
    const bufferLayers = new L.FeatureGroup().addTo(map);

    // Update buffer distance display when slider changes
    document.getElementById('buffer-distance').addEventListener('input', function () {
      document.getElementById('buffer-value').textContent = this.value;
    });

    // Add event listeners to buffer tool buttons
    document.getElementById('buffer-point').addEventListener('click', function () {
      // For point (circle), we need to create a custom interaction
      activatePointCircleTool();
      showNotification("Buffer Tool", "Click on map to create a circle with specified radius", "info");
    });

    document.getElementById('buffer-line').addEventListener('click', function () {
      // For line with width, use the Draw.Polyline but modify it after creation
      activateWidthLineTool();
      showNotification("Buffer Tool", "Draw a line that will have specified width", "info");
    });

    document.getElementById('buffer-polygon').addEventListener('click', function () {
      // For polygon, use the Draw.Polygon but buffer it after creation
      activateBufferedPolygonTool();
      showNotification("Buffer Tool", "Draw a polygon that will be buffered outward", "info");
    });

    // Clear all buffers
    document.getElementById('buffer-clear').addEventListener('click', function () {
      // Remove all layers from the feature group
      bufferLayers.eachLayer(function (layer) {
        bufferLayers.removeLayer(layer);
      });

      // Also ensure we remove any lingering buffer elements
      map.eachLayer(function (layer) {
        if (layer._bufferElement && layer !== bufferLayers) {
          map.removeLayer(layer);
        }
      });

      showNotification("Buffer Tool", "All buffer elements cleared", "info");
    });

    // Close the buffer toolbar
    document.getElementById('buffer-close').addEventListener('click', function () {
      document.getElementById('buffer-toolbar').style.display = 'none';
      deactivateAllTools();
    });

    // Update analysis dropdown handler
    document.querySelectorAll("#analysis-dropdown .dropdown-item").forEach(item => {
      item.addEventListener('click', function (e) {
        const analysisType = this.getAttribute("data-analysis");
        if (analysisType === 'buffer') {
          document.getElementById('buffer-toolbar').style.display = 'flex';
          showNotification("Buffer Tool", "Set buffer distance and select a drawing tool", "info");
        } else {
          document.getElementById('buffer-toolbar').style.display = 'none';
          deactivateAllTools();
        }
      });
    });

    // Point (Circle) Tool Activation
    function activatePointCircleTool() {
      deactivateAllTools();

      // Change cursor style
      map._container.style.cursor = 'crosshair';

      // Store the buffer click handler on the map
      map._bufferClickHandler = function (e) {
        const radius = parseFloat(document.getElementById('buffer-distance').value) * 1000; // Convert km to meters

        // Create a circle at the clicked location
        const circle = L.circle(e.latlng, {
          radius: radius,
          color: '#ff7800',
          weight: 2,
          opacity: 0.8,
          fillColor: '#ff7800',
          fillOpacity: 0.2
        });

        // Mark as buffer element for easier cleanup
        circle._bufferElement = true;

        // Add to buffer layers
        bufferLayers.addLayer(circle);

        // Add popup with information
        circle.bindPopup(`
        <div style="padding:5px;">
          <h4>Circle Buffer</h4>
          <p>Center: ${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}</p>
          <p>Radius: ${(radius / 1000).toFixed(1)} km</p>
          <button class="buffer-delete-btn" style="background-color:#e74c3c; color:white; border:none; padding:3px 8px; border-radius:3px; cursor:pointer; margin-top:5px; width:100%;">Delete</button>
        </div>
      `);

        // Add delete event handler to the popup
        circle.on('popupopen', function () {
          const deleteBtn = document.querySelector('.buffer-delete-btn');
          if (deleteBtn) {
            deleteBtn.addEventListener('click', function () {
              // Direct removal from map and buffer group
              map.removeLayer(circle);
              bufferLayers.removeLayer(circle);
              map.closePopup();
              showNotification("Buffer Deleted", "Circle buffer has been removed", "info");
            });
          }
        });

        showNotification("Circle Created", `Circle with ${(radius / 1000).toFixed(1)}km radius created`, "success");
      };

      // Add the click handler
      map.on('click', map._bufferClickHandler);
    }

    // Line with Width Tool Activation
    function activateWidthLineTool() {
      deactivateAllTools();

      // Use the Leaflet.Draw line tool but modify our draw:created handler
      map._bufferLineMode = true;
      const drawLineControl = new L.Draw.Polyline(map);
      drawLineControl.enable();
      map.drawHandler = drawLineControl;
    }

    // Buffered Polygon Tool Activation
    function activateBufferedPolygonTool() {
      deactivateAllTools();

      // Use the Leaflet.Draw polygon tool but modify our draw:created handler
      map._bufferPolygonMode = true;
      const drawPolygonControl = new L.Draw.Polygon(map);
      drawPolygonControl.enable();
      map.drawHandler = drawPolygonControl;
    }

    // Deactivate all tools
    function deactivateAllTools() {
      // Reset cursor
      map._container.style.cursor = '';

      // Remove point (circle) handler if active
      if (map._bufferClickHandler) {
        map.off('click', map._bufferClickHandler);
        map._bufferClickHandler = null;
      }

      // Reset line and polygon modes
      map._bufferLineMode = false;
      map._bufferPolygonMode = false;

      // Disable any active drawing
      if (map.drawHandler && map.drawHandler.disable) {
        map.drawHandler.disable();
        map.drawHandler = null;
      }

      // Try to cancel any active draw tools
      if (typeof L.Draw !== 'undefined') {
        try {
          // Force disable all drawing handlers
          Object.values(L.Draw.Event).forEach(eventName => {
            if (typeof eventName === 'string' && eventName.includes('CANCEL')) {
              map.fire(eventName);
            }
          });
        } catch (e) {
          console.log("Failed to cancel drawing:", e);
        }
      }
    }

    // Override the draw created event to handle buffered features
    map.on('draw:created', function (e) {
      const layer = e.layer;

      // Only apply special handling if buffer toolbar is visible
      if (document.getElementById('buffer-toolbar').style.display === 'flex') {
        // Get buffer distance in kilometers
        const distanceKm = parseFloat(document.getElementById('buffer-distance').value);

        if (map._bufferLineMode && e.layerType === 'polyline') {
          // For line with width, create a buffered line and don't add the original
          createBufferedLine(layer, distanceKm);
        }
        else if (map._bufferPolygonMode && e.layerType === 'polygon') {
          // For polygon, create a buffered polygon and don't add the original
          createBufferedPolygon(layer, distanceKm);
        }
        else {
          // In any other case, add to the buffer layers group for proper management
          layer._bufferElement = true;
          bufferLayers.addLayer(layer);
        }

        // Reset buffer modes
        map._bufferLineMode = false;
        map._bufferPolygonMode = false;
      }
      else {
        // For normal drawing, add the layer to the map as usual
        map.addLayer(layer);
      }
    });

    // Create buffered line (line with width)
    function createBufferedLine(lineLayer, widthKm) {
      try {
        // Convert Leaflet line to GeoJSON
        const lineGeoJSON = lineLayer.toGeoJSON();

        // Use turf.js to create buffer
        const buffered = turf.buffer(lineGeoJSON, widthKm, { units: 'kilometers' });

        // Add the buffered line to the map
        const bufferLayer = L.geoJSON(buffered, {
          style: {
            color: '#ff7800',
            weight: 2,
            opacity: 0.8,
            fillColor: '#ff7800',
            fillOpacity: 0.2
          }
        });

        // Mark as buffer element for easier cleanup
        bufferLayer._bufferElement = true;

        // Add to the buffer layers group
        bufferLayers.addLayer(bufferLayer);

        // Store reference to the original line for deletion
        bufferLayer._originalLine = lineLayer;

        // Add a popup with information and delete button
        bufferLayer.bindPopup(`
        <div style="padding:5px;">
          <h4>Buffered Line</h4>
          <p>Width: ${widthKm} km</p>
          <button class="buffer-delete-btn" style="background-color:#e74c3c; color:white; border:none; padding:3px 8px; border-radius:3px; cursor:pointer; margin-top:5px; width:100%;">Delete</button>
        </div>
      `);

        // Add delete event handler to the popup
        bufferLayer.on('popupopen', function () {
          const deleteBtn = document.querySelector('.buffer-delete-btn');
          if (deleteBtn) {
            deleteBtn.addEventListener('click', function () {
              // Direct removal from map and buffer group
              map.removeLayer(bufferLayer);
              bufferLayers.removeLayer(bufferLayer);

              // Make sure original line is also removed if it exists
              if (bufferLayer._originalLine) {
                if (map.hasLayer(bufferLayer._originalLine)) {
                  map.removeLayer(bufferLayer._originalLine);
                }
              }

              map.closePopup();
              showNotification("Buffer Deleted", "Line buffer has been removed", "info");
            });
          }
        });

        showNotification("Buffered Line Created", `Line with ${widthKm}km width created`, "success");

        return bufferLayer;
      } catch (error) {
        console.error("Error creating buffered line:", error);
        showNotification("Error", "Failed to create buffered line: " + error.message, "error");
      }
    }

    // Create buffered polygon
    function createBufferedPolygon(polygonLayer, bufferKm) {
      try {
        // Convert Leaflet polygon to GeoJSON
        const polygonGeoJSON = polygonLayer.toGeoJSON();

        // Use turf.js to create buffer
        const buffered = turf.buffer(polygonGeoJSON, bufferKm, { units: 'kilometers' });

        // Add the buffered polygon to the map
        const bufferLayer = L.geoJSON(buffered, {
          style: {
            color: '#ff7800',
            weight: 2,
            opacity: 0.8,
            fillColor: '#ff7800',
            fillOpacity: 0.2
          }
        });

        // Mark as buffer element for easier cleanup
        bufferLayer._bufferElement = true;

        // Add to the buffer layers group
        bufferLayers.addLayer(bufferLayer);

        // Store reference to the original polygon for deletion
        bufferLayer._originalPolygon = polygonLayer;

        // Add a popup with information and delete button
        bufferLayer.bindPopup(`
        <div style="padding:5px;">
          <h4>Buffered Polygon</h4>
          <p>Buffer Distance: ${bufferKm} km</p>
          <button class="buffer-delete-btn" style="background-color:#e74c3c; color:white; border:none; padding:3px 8px; border-radius:3px; cursor:pointer; margin-top:5px; width:100%;">Delete</button>
        </div>
      `);

        // Add delete event handler to the popup
        bufferLayer.on('popupopen', function () {
          const deleteBtn = document.querySelector('.buffer-delete-btn');
          if (deleteBtn) {
            deleteBtn.addEventListener('click', function () {
              // Direct removal from map and buffer group
              map.removeLayer(bufferLayer);
              bufferLayers.removeLayer(bufferLayer);

              // Make sure original polygon is also removed if it exists
              if (bufferLayer._originalPolygon) {
                if (map.hasLayer(bufferLayer._originalPolygon)) {
                  map.removeLayer(bufferLayer._originalPolygon);
                }
              }

              map.closePopup();
              showNotification("Buffer Deleted", "Polygon buffer has been removed", "info");
            });
          }
        });

        showNotification("Buffered Polygon Created", `Polygon with ${bufferKm}km buffer created`, "success");

        return bufferLayer;
      } catch (error) {
        console.error("Error creating buffered polygon:", error);
        showNotification("Error", "Failed to create buffered polygon: " + error.message, "error");
      }
    }
  });
  ///////////////////

</script>
{% endblock %}