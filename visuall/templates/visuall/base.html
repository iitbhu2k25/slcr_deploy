<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>India GIS Raster Data Viewer</title>
    <!-- CSS Libraries -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Add html2canvas library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
      /* Essential custom styles that can't be replaced with Bootstrap */
      body {
        font-family: "Poppins", sans-serif;
      }

      /* Map container styles */
      .map-container {
        position: relative;
        height: 70vh;
        overflow: hidden;
        border-radius: 0 0.5rem 0.5rem 0;
      }

      #map {
        height: 100%;
        width: 100%;
        z-index: 1;
      }

      /* Compass styles */
      .compass-container {
        position: absolute;
        top: 80px;
        left: 20px;
        z-index: 990;
        width: 100px;
        height: 100px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        backdrop-filter: blur(5px);
      }

      .compass-rose {
        width: 90px;
        height: 90px;
        position: relative;
        animation: compass-fade-in 1s ease;
      }

      .compass-ring {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: 2px solid rgba(52, 152, 219, 0.2);
        border-radius: 50%;
      }

      .compass-face {
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        bottom: 5px;
        border-radius: 50%;
        background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
        box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .compass-needle {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 70%;
        transform: translate(-50%, -50%);
        transform-origin: center;
      }

      .needle-north {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background: linear-gradient(to top, transparent 0%, #e74c3c 100%);
        clip-path: polygon(0 0, 100% 0, 50% 100%);
        transform-origin: bottom center;
        box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.2);
      }

      .needle-south {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background: linear-gradient(to bottom, transparent 0%, #2c3e50 100%);
        clip-path: polygon(0 100%, 100% 100%, 50% 0);
        transform-origin: top center;
      }

      .compass-center {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 12px;
        height: 12px;
        background: radial-gradient(circle, #fff 0%, #ddd 70%, #bbb 100%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 3;
      }

      .compass-cardinal-points {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        font-weight: 600;
        font-size: 12px;
        pointer-events: none;
      }

      .compass-n {
        position: absolute;
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
        color: #e74c3c;
      }
      .compass-ne {
        position: absolute;
        top: 18%;
        right: 18%;
        color: #555;
        font-size: 10px;
      }
      .compass-e {
        position: absolute;
        top: 50%;
        right: 5px;
        transform: translateY(-50%);
        color: #555;
      }
      .compass-se {
        position: absolute;
        bottom: 18%;
        right: 18%;
        color: #555;
        font-size: 10px;
      }
      .compass-s {
        position: absolute;
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
        color: #555;
      }
      .compass-sw {
        position: absolute;
        bottom: 18%;
        left: 18%;
        color: #555;
        font-size: 10px;
      }
      .compass-w {
        position: absolute;
        top: 50%;
        left: 5px;
        transform: translateY(-50%);
        color: #555;
      }
      .compass-nw {
        position: absolute;
        top: 18%;
        left: 18%;
        color: #555;
        font-size: 10px;
      }

      .compass-degrees {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
      }

      .compass-degrees::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: conic-gradient(
          from 0deg,
          transparent 0deg,
          transparent 29deg,
          rgba(52, 152, 219, 0.15) 30deg,
          rgba(52, 152, 219, 0.15) 59deg,
          transparent 60deg,
          transparent 89deg,
          rgba(52, 152, 219, 0.15) 90deg,
          rgba(52, 152, 219, 0.15) 119deg,
          transparent 120deg,
          transparent 149deg,
          rgba(52, 152, 219, 0.15) 150deg,
          rgba(52, 152, 219, 0.15) 179deg,
          transparent 180deg,
          transparent 209deg,
          rgba(52, 152, 219, 0.15) 210deg,
          rgba(52, 152, 219, 0.15) 239deg,
          transparent 240deg,
          transparent 269deg,
          rgba(52, 152, 219, 0.15) 270deg,
          rgba(52, 152, 219, 0.15) 299deg,
          transparent 300deg,
          transparent 329deg,
          rgba(52, 152, 219, 0.15) 330deg,
          rgba(52, 152, 219, 0.15) 359deg
        );
        opacity: 0.8;
      }

      /* Legend styles */
      .legend-color {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      /* Coordinate label styles */
      .coordinate-label {
        background: none !important;
        font-size: 12px;
        color: #333;
        font-weight: bold;
        text-shadow: 1px 1px 2px white;
      }

      /* Animations */
      @keyframes compass-fade-in {
        from {
          opacity: 0;
          transform: scale(0.8) rotate(-20deg);
        }
        to {
          opacity: 1;
          transform: scale(1) rotate(0);
        }
      }

      @keyframes pulse-light {
        0% {
          opacity: 0.7;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.7;
        }
      }

      @keyframes pulse {
        0% {
          transform: scale(0);
          opacity: 0.5;
        }
        100% {
          transform: scale(1.5);
          opacity: 0;
        }
      }

      @keyframes pulse-animation {
        0% {
          transform: scale(1);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.2);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 0;
        }
      }

      /* Map controls positioning */
      .map-controls {
        position: absolute;
        right: 20px;
        bottom: 30px;
        z-index: 999;
      }

      /* Info panel positioning */
      .info-panel {
        position: absolute;
        bottom: 30px;
        left: 20px;
        z-index: 999;
        min-width: 200px;
      }

      /* Map legend positioning */
      .map-legend {
        position: absolute;
        bottom: 30px;
        right: 80px;
        z-index: 999;
        min-width: 220px;
        max-height: 300px;
        overflow-y: auto;
      }

      /* Tooltip positioning */
      .data-tooltip {
        position: absolute;
        bottom: 130px;
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.5s ease, transform 0.5s ease;
        pointer-events: none;
        z-index: 1000;
      }

      .data-tooltip.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-10px);
      }

      /* For sidebar toggle */
      .toggle-sidebar {
        position: absolute;
        left: 300px;
        top: 20px;
        z-index: 999;
        transition: all 0.3s;
      }

      .toggle-sidebar.collapsed {
        left: 20px;
      }

      .sidebar {
        width: 300px;
        transition: all 0.3s;
        z-index: 100;
      }

      .sidebar.collapsed {
        width: 0;
        padding: 0;
        overflow: hidden;
      }

      /* Export button positioning */
      .export-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1000;
      }

      /* Custom slider styles */
      .custom-range {
        width: 100%;
        height: 10px;
        border-radius: 5px;
        -webkit-appearance: none;
        background: linear-gradient(90deg, #e9ecef 0%, #4caf50 100%);
        outline: none;
      }

      .custom-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      .custom-range::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      /* Slider value display */
      .range-value {
        background: #4caf50;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 12px;
        font-weight: bold;
        display: inline-block;
        min-width: 30px;
        text-align: center;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .content-wrapper {
          flex-direction: column;
        }
        .sidebar {
          width: 100%;
          max-height: 300px;
        }
        .sidebar.collapsed {
          max-height: 0;
        }
        .toggle-sidebar {
          top: 300px;
          left: 20px;
        }
        .toggle-sidebar.collapsed {
          top: 20px;
        }
        .map-container {
          height: 60vh;
        }
        .export-btn {
          right: 20px;
          top: 70px;
        }
        .compass-container {
          top: 140px;
          left: 20px;
          width: 70px;
          height: 70px;
        }
        .compass-rose {
          width: 60px;
          height: 60px;
        }
        .map-legend {
          right: 20px;
          bottom: 80px;
        }
      }
    </style>
  </head>
  <body>
    {% include 'header.html' %} {% include 'navbar.html' %}

    <div class="container-fluid py-3 bg-light">
      <div class="row justify-content-center">
        <div class="col-12 col-xl-11">
          <!-- App Header -->
          <div class="card mb-4 bg-primary text-white">
            <div class="card-body">
              <div class="row align-items-center">
                <div class="col-md-6">
                  <div class="d-flex align-items-center">
                    <i class="fas fa-globe-asia fa-2x me-2"></i>
                    <h3 class="m-0">India GIS Raster Data Viewer</h3>
                  </div>
                </div>
                <div class="col-md-6 text-end">
                  <span>Advanced Geospatial Analysis Tool</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Main Content -->
          <div class="card shadow-sm">
            <div class="card-body p-0">
              <div class="d-flex position-relative">
                <!-- Sidebar -->
                <div class="sidebar bg-white p-3 border-end" id="sidebar">
                  <div
                    class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-3"
                  >
                    <h5 class="m-0 fw-bold text-secondary">Control Panel</h5>
                  </div>

                  <!-- Data Selection Section -->
                  <div class="card bg-light mb-3">
                    <div class="card-body">
                      <h6 class="card-title d-flex align-items-center">
                        <i class="fas fa-database text-primary me-2"></i> Data
                        Selection
                      </h6>

                      <!-- Category Selection -->
                      <div class="mb-3" id="category-wrapper">
                        <label class="form-label">Category</label>
                        <select class="form-select" id="category-dropdown">
                          <option value="" disabled selected>
                            Loading categories...
                          </option>
                        </select>
                        <div
                          class="text-success mt-1 small"
                          id="category-indicator"
                          style="display: none"
                        >
                          <i class="fas fa-check-circle"></i> Categories loaded
                        </div>
                      </div>

                      <!-- Raster Files Selection -->
                      <div class="mb-3" id="raster-wrapper">
                        <label class="form-label">Raster File</label>
                        <select
                          class="form-select"
                          id="raster-dropdown"
                          disabled
                        >
                          <option value="" disabled selected>
                            Select a category first
                          </option>
                        </select>
                        <div
                          class="text-success mt-1 small"
                          id="raster-indicator"
                          style="display: none"
                        >
                          <i class="fas fa-check-circle"></i>
                          <span id="raster-count">0</span> files available
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- Map Options Section -->
                  <div class="card bg-light mb-3">
                    <div class="card-body">
                      <h6 class="card-title d-flex align-items-center">
                        <i class="fas fa-layer-group text-primary me-2"></i> Map
                        Options
                      </h6>

                      <!-- Base Map Dropdown -->
                      <div class="dropdown mb-3" id="basemap-dropdown">
                        <button
                          class="btn btn-white border dropdown-toggle w-100 text-start d-flex justify-content-between align-items-center"
                          type="button"
                          data-bs-toggle="dropdown"
                        >
                          <div>
                            <i class="fas fa-map text-primary me-2"></i> Base
                            Map
                          </div>
                        </button>
                        <ul class="dropdown-menu w-100">
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-basemap="streets"
                              ><i class="fas fa-road text-primary me-2"></i>
                              Streets</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-basemap="satellite"
                              ><i
                                class="fas fa-satellite text-primary me-2"
                              ></i>
                              Satellite</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-basemap="terrain"
                              ><i class="fas fa-mountain text-primary me-2"></i>
                              Terrain</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-basemap="hybrid"
                              ><i class="fas fa-globe text-primary me-2"></i>
                              Hybrid</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-basemap="cartoVoyager"
                              ><i class="fas fa-compass text-primary me-2"></i>
                              Carto Voyager</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-basemap="none"
                              ><i class="fas fa-ban text-primary me-2"></i> No
                              Basemap</a
                            >
                          </li>
                        </ul>
                      </div>

                      <!-- Drawing Tools Dropdown -->
                      <div class="dropdown mb-3" id="drawing-dropdown">
                        <button
                          class="btn btn-white border dropdown-toggle w-100 text-start d-flex justify-content-between align-items-center"
                          type="button"
                          data-bs-toggle="dropdown"
                        >
                          <div>
                            <i class="fas fa-pencil-alt text-primary me-2"></i>
                            Drawing Tools
                          </div>
                        </button>
                        <ul class="dropdown-menu w-100">
                          <li>
                            <a class="dropdown-item" href="#" data-tool="point"
                              ><i
                                class="fas fa-map-marker-alt text-primary me-2"
                              ></i>
                              Add Point</a
                            >
                          </li>
                          <li>
                            <a class="dropdown-item" href="#" data-tool="line"
                              ><i class="fas fa-slash text-primary me-2"></i>
                              Draw Line</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-tool="polygon"
                              ><i
                                class="fas fa-draw-polygon text-primary me-2"
                              ></i>
                              Draw Polygon</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-tool="measure"
                              ><i class="fas fa-ruler text-primary me-2"></i>
                              Measure</a
                            >
                          </li>
                          <li>
                            <a class="dropdown-item" href="#" data-tool="clear"
                              ><i
                                class="fas fa-trash-alt text-primary me-2"
                              ></i>
                              Clear All</a
                            >
                          </li>
                        </ul>
                      </div>

                      <!-- Analysis Tools Dropdown -->
                      <div class="dropdown mb-3" id="analysis-dropdown">
                        <button
                          class="btn btn-white border dropdown-toggle w-100 text-start d-flex justify-content-between align-items-center"
                          type="button"
                          data-bs-toggle="dropdown"
                        >
                          <div>
                            <i class="fas fa-chart-line text-primary me-2"></i>
                            Analysis Tools
                          </div>
                        </button>
                        <ul class="dropdown-menu w-100">
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-analysis="elevation"
                              ><i class="fas fa-mountain text-primary me-2"></i>
                              Elevation Profile</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-analysis="viewshed"
                              ><i class="fas fa-eye text-primary me-2"></i>
                              Viewshed Analysis</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-analysis="buffer"
                              ><i
                                class="fas fa-expand-alt text-primary me-2"
                              ></i>
                              Buffer Zone</a
                            >
                          </li>
                          <li>
                            <a
                              class="dropdown-item"
                              href="#"
                              data-analysis="statistics"
                              ><i
                                class="fas fa-calculator text-primary me-2"
                              ></i>
                              Zonal Statistics</a
                            >
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>

                  <!-- Display Settings Section -->
                  <div class="card bg-light">
                    <div class="card-body">
                      <h6 class="card-title d-flex align-items-center">
                        <i class="fas fa-sliders-h text-primary me-2"></i>
                        Display Settings
                      </h6>

                      <!-- NEW: Opacity Slider -->
                      <div class="mb-3">
                        <label
                          class="form-label d-flex justify-content-between align-items-center"
                        >
                          <span>Opacity</span>
                          <span class="range-value" id="opacity-value">10</span>
                        </label>
                        <input
                          type="range"
                          class="form-range custom-range"
                          id="opacity-slider"
                          min="1"
                          max="10"
                          value="10"
                        />
                      </div>

                      <!-- NEW: Legend Items Count Slider -->
                      <div class="mb-3">
                        <label
                          class="form-label d-flex justify-content-between align-items-center"
                        >
                          <span>Legend Items</span>
                          <span class="range-value" id="legend-count-value"
                            >5</span
                          >
                        </label>
                        <input
                          type="range"
                          class="form-range custom-range"
                          id="legend-count-slider"
                          min="2"
                          max="10"
                          value="5"
                        />
                      </div>

                      <!-- NEW: Zoom Level Slider -->
                      <div class="mb-3">
                        <label
                          class="form-label d-flex justify-content-between align-items-center"
                        >
                          <span>Zoom Level</span>
                          <span class="range-value" id="zoom-level-value"
                            >8</span
                          >
                        </label>
                        <input
                          type="range"
                          class="form-range custom-range"
                          id="zoom-level-slider"
                          min="5"
                          max="16"
                          value="8"
                        />
                      </div>

                      <div class="form-check form-switch mb-2">
                        <input
                          class="form-check-input"
                          type="checkbox"
                          id="grid-toggle"
                          checked
                        />
                        <label class="form-check-label" for="grid-toggle"
                          >Coordinate Grid</label
                        >
                      </div>

                      <div class="form-check form-switch mb-2">
                        <input
                          class="form-check-input"
                          type="checkbox"
                          id="legend-toggle"
                          checked
                        />
                        <label class="form-check-label" for="legend-toggle"
                          >Show Legend</label
                        >
                      </div>

                      <div class="form-check form-switch">
                        <input
                          class="form-check-input"
                          type="checkbox"
                          id="compass-toggle"
                          checked
                        />
                        <label class="form-check-label" for="compass-toggle"
                          >Show Compass</label
                        >
                      </div>

                      <!-- Apply Settings Button -->
                      <button
                        class="btn btn-primary w-100 mt-3"
                        id="apply-settings-btn"
                      >
                        <i class="fas fa-sync-alt me-2"></i> Apply Settings
                      </button>
                    </div>
                  </div>
                </div>

                <!-- Sidebar Toggle Button -->
                <button
                  class="toggle-sidebar btn btn-white rounded-circle shadow-sm"
                  id="toggle-sidebar"
                >
                  <i class="fas fa-chevron-left" id="toggle-icon"></i>
                </button>

                <!-- Map Container -->
                <div class="map-container flex-grow-1">
                  <div id="map"></div>

                  <!-- Modern Compass -->
                  <div class="compass-container" id="compass">
                    <div class="compass-rose">
                      <div class="compass-ring"></div>
                      <div class="compass-face"></div>
                      <div class="compass-needle">
                        <div class="needle-north"></div>
                        <div class="needle-south"></div>
                      </div>
                      <div class="compass-center"></div>
                      <div class="compass-cardinal-points">
                        <span class="compass-n">N</span>
                        <span class="compass-ne">NE</span>
                        <span class="compass-e">E</span>
                        <span class="compass-se">SE</span>
                        <span class="compass-s">S</span>
                        <span class="compass-sw">SW</span>
                        <span class="compass-w">W</span>
                        <span class="compass-nw">NW</span>
                      </div>
                      <div class="compass-degrees"></div>
                    </div>
                  </div>

                  <!-- Rotation Control Button -->
                  <div
                    class="btn btn-light rounded-circle shadow-sm position-absolute"
                    style="top: 80px; right: 20px; z-index: 990"
                    id="rotation-control"
                  >
                    <i class="fas fa-sync-alt"></i>
                  </div>

                  <!-- Export Button -->
                  <button
                    class="export-btn btn btn-white shadow-sm"
                    id="export-btn"
                  >
                    <i class="fas fa-file-pdf text-primary me-2"></i> Export PDF
                  </button>

                  <!-- Map Controls -->
                  <div
                    class="map-controls d-flex flex-column bg-white rounded-3 shadow-sm p-1"
                  >
                    <button
                      class="btn btn-white rounded-3 mb-1"
                      id="zoom-in-btn"
                      title="Zoom In"
                    >
                      <i class="fas fa-plus"></i>
                    </button>
                    <button
                      class="btn btn-white rounded-3 mb-1"
                      id="zoom-out-btn"
                      title="Zoom Out"
                    >
                      <i class="fas fa-minus"></i>
                    </button>
                    <button
                      class="btn btn-white rounded-3 mb-1"
                      id="home-btn"
                      title="Default View"
                    >
                      <i class="fas fa-home"></i>
                    </button>
                    <button
                      class="btn btn-white rounded-3 mb-1 position-relative"
                      id="locate-btn"
                      title="My Location"
                    >
                      <i class="fas fa-location-arrow"></i>
                    </button>
                    <button
                      class="btn btn-white rounded-3"
                      id="fullscreen-btn"
                      title="Fullscreen"
                    >
                      <i class="fas fa-expand"></i>
                    </button>
                  </div>

                  <!-- Info Panel -->
                  <div class="info-panel bg-white rounded-3 shadow-sm p-3">
                    <div
                      class="badge bg-primary mb-2 px-3 py-2"
                      id="current-layer-display"
                    >
                      No Data Loaded
                    </div>
                    <div>
                      <small>Coordinates:</small>
                      <div id="coordinates-display">0.00000, 0.00000</div>
                    </div>
                  </div>

                  <!-- Map Legend -->
                  <div
                    class="map-legend bg-white rounded-3 shadow-sm p-3"
                    id="map-legend"
                  >
                    <div class="fw-bold border-bottom border-primary pb-2 mb-2">
                      <span class="legend-title">Raster Legend</span>
                    </div>
                    <div id="legend-content">
                      <!-- Legend will be dynamically populated -->
                    </div>
                  </div>

                  <!-- Data Tooltip -->
                  <div
                    class="data-tooltip bg-primary text-white py-2 px-3 rounded-3 shadow-sm"
                    id="data-tooltip"
                  >
                    Loading data...
                  </div>

                  <!-- Coordinates Tooltip -->
                  <div
                    class="coordinates-tooltip bg-dark text-white py-2 px-3 rounded-3"
                    id="coordinates-tooltip"
                  >
                    Lat: 20.5937, Lng: 78.9629<br />
                    <small>UTM: 43Q 791543 2278410</small>
                  </div>

                  <!-- Loader -->
                  <div
                    class="loader position-absolute top-50 start-50 translate-middle bg-white rounded-3 shadow-sm p-4 d-none"
                    id="loader"
                  >
                    <div class="d-flex align-items-center">
                      <div
                        class="spinner-border text-primary me-3"
                        role="status"
                      ></div>
                      <span>Loading data...</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Export Modal Dialog -->
    <div class="modal fade" id="exportModal" tabindex="-1">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header bg-primary text-white">
            <h5 class="modal-title">Export Map as PDF</h5>
            <button
              type="button"
              class="btn-close btn-close-white"
              data-bs-dismiss="modal"
            ></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="exportTitle" class="form-label">Map Title</label>
              <input
                type="text"
                class="form-control"
                id="exportTitle"
                placeholder="Enter map title"
                value="India GIS Raster Map"
              />
            </div>

            <div class="mb-3">
              <label for="exportLayout" class="form-label">Paper Format</label>
              <select class="form-select" id="exportLayout">
                <option value="a4-portrait">A4 Portrait</option>
                <option value="a4-landscape" selected>A4 Landscape</option>
                <option value="a3-portrait">A3 Portrait</option>
                <option value="a3-landscape">A3 Landscape</option>
                <option value="letter-portrait">Letter Portrait</option>
                <option value="letter-landscape">Letter Landscape</option>
              </select>
            </div>

            <div class="mb-3">
              <label for="exportDPI" class="form-label">Resolution (DPI)</label>
              <select class="form-select" id="exportDPI">
                <option value="150">150 DPI (Draft)</option>
                <option value="300" selected>300 DPI (Standard)</option>
                <option value="600">600 DPI (High Quality)</option>
              </select>
            </div>

            <div class="mb-3">
              <label class="form-label">Export Options</label>
              <div class="form-check mb-2">
                <input
                  class="form-check-input"
                  type="checkbox"
                  id="exportLegend"
                  checked
                />
                <label class="form-check-label" for="exportLegend"
                  >Include Legend</label
                >
              </div>
              <div class="form-check mb-2">
                <input
                  class="form-check-input"
                  type="checkbox"
                  id="exportCoordinates"
                  checked
                />
                <label class="form-check-label" for="exportCoordinates"
                  >Include Coordinate Grid</label
                >
              </div>
              <div class="form-check">
                <input
                  class="form-check-input"
                  type="checkbox"
                  id="exportVectors"
                  checked
                />
                <label class="form-check-label" for="exportVectors"
                  >Include Drawn Features</label
                >
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Cancel
            </button>
            <button type="button" class="btn btn-primary" id="confirmExport">
              Export
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Toast Notification -->
    <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
      <div
        id="notification"
        class="toast border-start border-4 border-primary"
        role="alert"
        aria-live="assertive"
        aria-atomic="true"
      >
        <div class="toast-header">
          <i
            class="fas fa-check-circle text-success me-2"
            id="notification-icon"
          ></i>
          <strong class="me-auto" id="notification-title">Success</strong>
          <button
            type="button"
            class="btn-close"
            data-bs-dismiss="toast"
          ></button>
        </div>
        <div class="toast-body" id="notification-text">
          Data loaded successfully.
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/georaster"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>

    <script>
            // Wait for DOM to be fully loaded
            document.addEventListener("DOMContentLoaded", function () {
              // India coordinates and constants
              const INDIA_CENTER = [20.5937, 78.9629];
              const INDIA_ZOOM = 5;

              // Initialize the map with zoomSnap for smoother zoom
              const map = L.map("map", {
                center: INDIA_CENTER,
                zoom: INDIA_ZOOM,
                minZoom: 4,
                maxZoom: 18,
                zoomControl: false, // We'll add our own zoom controls
                zoomSnap: 0.25, // Enable smoother zooming
                zoomDelta: 0.5, // Smaller zoom increments for finer control
                wheelPxPerZoomLevel: 120 // Adjust mouse wheel sensitivity
              });

              // Base layers from free providers
              const baseLayers = {
                streets:  L.tileLayer(
                "https://{s}.google.com/vt/lyrs=m@221097413,traffic&x={x}&y={y}&z={z}",
                {
                  subdomains: ["mt0", "mt1", "mt2", "mt3"],
                  attribution:
                    '&copy; <a href="https://www.google.com/maps">Google Traffic</a>',
                }
              ),

                satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                  maxZoom: 18
                }),

                terrain: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                  attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
                  maxZoom: 17
                }),

                // For the "hybrid" layer, we create a layerGroup that combines satellite imagery with labels
                hybrid: L.layerGroup([
                  L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                    maxZoom: 18
                  }),
                  L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-labels/{z}/{x}/{y}{r}.png', {
                    attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    subdomains: 'abcd',
                    maxZoom: 20,
                    opacity: 0.7
                  })
                ]),

              

                // Stamen Watercolor base map
                watercolor: L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.{ext}', {
                  attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                  subdomains: 'abcd',
                  minZoom: 1,
                  maxZoom: 16,
                  ext: 'jpg'
                }),

                // CartoDB Voyager
                cartoVoyager: L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                  subdomains: 'abcd',
                  maxZoom: 19
                }),
                traffic1: L.tileLayer(
                "https://{s}.google.com/vt/lyrs=m@221097413,traffic&x={x}&y={y}&z={z}",
                {
                  subdomains: ["mt0", "mt1", "mt2", "mt3"],
                  attribution:
                    '&copy; <a href="https://www.google.com/maps">Google Traffic</a>',
                }
              ),

              none: L.tileLayer('', {
                attribution: 'No basemap'
              })
            };

            // Add default basemap
            baseLayers.traffic1.addTo(map);

              // Add scale control
              L.control
                .scale({
                  imperial: false,
                  position: "bottomright",
                })
                .addTo(map);

              // Track state
              let currentRasterLayer = null;
              let currentRasterBounds = null;
              let gridLines = [];
              let mapRotation = 0;
              let currentCategory = null;
              let currentRasterFile = null;
              let rasterMetadata = null; // To store raster metadata for dynamic legends
              let currentGeoRaster = null; // Store the georaster object for rerendering

              // Settings
              let currentOpacity = 1.0;
              let currentLegendCount = 5;
              let currentZoomLevel = 8;

              // Drawing layer
              const drawnItems = new L.FeatureGroup();
              map.addLayer(drawnItems);

              // Initialize UI elements
              const compassToggle = document.getElementById("compass-toggle");
              const gridToggle = document.getElementById("grid-toggle");
              const legendToggle = document.getElementById("legend-toggle");
              const coordTooltip = document.getElementById("coordinates-tooltip");
              const categoryDropdown = document.getElementById("category-dropdown");
              const rasterDropdown = document.getElementById("raster-dropdown");
              const rasterWrapper = document.getElementById("raster-wrapper");
              const loader = document.getElementById("loader");
              const dataTooltip = document.getElementById("data-tooltip");

              // Sliders
              const opacitySlider = document.getElementById("opacity-slider");
              const legendCountSlider = document.getElementById("legend-count-slider");
              const zoomLevelSlider = document.getElementById("zoom-level-slider");
              const opacityValue = document.getElementById("opacity-value");
              const legendCountValue = document.getElementById("legend-count-value");
              const zoomLevelValue = document.getElementById("zoom-level-value");
              const applySettingsBtn = document.getElementById("apply-settings-btn");

              // Initialize settings values
              currentOpacity = parseInt(opacitySlider.value);
              currentLegendCount = parseInt(legendCountSlider.value);
              currentZoomLevel = parseInt(zoomLevelSlider.value);

              // Hide coordinate tooltip by default
              coordTooltip.style.display = "none";

              // Initialize Bootstrap toast for notifications
              const notificationToast = new bootstrap.Toast(
                document.getElementById("notification")
              );

              // Function to change basemap (similar to vector viewer)
              function changeBasemap(basemapId) {
                console.log("Changing basemap to:", basemapId);

                // If we have a raster layer, temporarily remove it
                let rasterWasVisible = false;
                if (currentRasterLayer && map.hasLayer(currentRasterLayer)) {
                  console.log("Temporarily removing raster layer");
                  rasterWasVisible = true;
                  map.removeLayer(currentRasterLayer);
                }

                // Remove all current basemap layers
                Object.values(baseLayers).forEach((layer) => {
                  if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                  }
                });

                // Add selected layer if it's not 'none'
                if (basemapId !== "none") {
                  map.addLayer(baseLayers[basemapId]);
                }

                // Re-add the raster layer on top if it was visible
                if (rasterWasVisible && currentRasterLayer) {
                  console.log("Re-adding raster layer on top of new basemap");
                  currentRasterLayer.addTo(map);

                  // Make sure we maintain the same view/zoom level
                  if (currentRasterBounds && currentRasterBounds.isValid()) {
                    console.log(
                      "Maintaining zoom to raster bounds:",
                      currentRasterBounds.toString()
                    );
                    try {
                      map.fitBounds(currentRasterBounds, {
                        padding: [20, 20],
                        maxZoom: currentZoomLevel,
                        animate: true,
                      });
                    } catch (error) {
                      console.error(
                        "Error during fitBounds after basemap change:",
                        error
                      );
                    }
                  }
                }

                // Show notification
                const basemapName =
                  basemapId.charAt(0).toUpperCase() + basemapId.slice(1);
                showNotification(
                  "Basemap Changed",
                  `Switched to ${basemapName} basemap`,
                  "info"
                );
              }

              // Show notification function (updated for Bootstrap toast)
              function showNotification(title, message, type = "success") {
                const notification = document.getElementById("notification");
                const notificationIcon = document.getElementById("notification-icon");
                const notificationTitle =
                  document.getElementById("notification-title");
                const notificationText = document.getElementById("notification-text");

                // Set content
                notificationTitle.textContent = title;
                notificationText.textContent = message;

                // Remove previous classes
                notification.classList.remove(
                  "border-success",
                  "border-danger",
                  "border-info",
                  "border-warning"
                );
                notificationIcon.classList.remove(
                  "text-success",
                  "text-danger",
                  "text-info",
                  "text-warning"
                );
                notificationIcon.classList.remove(
                  "fa-check-circle",
                  "fa-exclamation-circle",
                  "fa-info-circle",
                  "fa-exclamation-triangle"
                );

                // Set icon and color based on type
                if (type === "success") {
                  notification.classList.add("border-success");
                  notificationIcon.classList.add("text-success", "fa-check-circle");
                } else if (type === "error") {
                  notification.classList.add("border-danger");
                  notificationIcon.classList.add(
                    "text-danger",
                    "fa-exclamation-circle"
                  );
                } else if (type === "info") {
                  notification.classList.add("border-info");
                  notificationIcon.classList.add("text-info", "fa-info-circle");
                } else if (type === "warning") {
                  notification.classList.add("border-warning");
                  notificationIcon.classList.add(
                    "text-warning",
                    "fa-exclamation-triangle"
                  );
                }

                // Show notification
                notificationToast.show();
              }

              // Function to add coordinate grid lines
              function addCoordinateGrid() {
                // Clear previous grid lines
                gridLines.forEach((line) => {
                  if (map.hasLayer(line)) {
                    map.removeLayer(line);
                  }
                });
                gridLines = [];

                // Latitude lines (every 5 degrees)
                for (let lat = 5; lat <= 40; lat += 5) {
                  const line = L.polyline(
                    [
                      [lat, 65],
                      [lat, 100],
                    ],
                    {
                      color: "#3498db",
                      weight: 1,
                      opacity: 0.5,
                      dashArray: "5,5",
                    }
                  ).addTo(map);

                  const label = L.marker([lat, 65], {
                    icon: L.divIcon({
                      className: "coordinate-label",
                      html: `${lat}°N`,
                      iconSize: [40, 20],
                      iconAnchor: [0, 10],
                    }),
                  }).addTo(map);

                  gridLines.push(line, label);
                }

                // Longitude lines (every 5 degrees)
                for (let lng = 65; lng <= 100; lng += 5) {
                  const line = L.polyline(
                    [
                      [5, lng],
                      [40, lng],
                    ],
                    {
                      color: "#3498db",
                      weight: 1,
                      opacity: 0.5,
                      dashArray: "5,5",
                    }
                  ).addTo(map);

                  const label = L.marker([5, lng], {
                    icon: L.divIcon({
                      className: "coordinate-label",
                      html: `${lng}°E`,
                      iconSize: [40, 20],
                      iconAnchor: [20, -5],
                    }),
                  }).addTo(map);

                  gridLines.push(line, label);
                }
              }

              // Enhanced dynamic legend with actual data ranges and descriptions
              function updateDynamicLegend(category, metadata) {
                const legendContent = document.getElementById("legend-content");
                legendContent.innerHTML = "";

                // Get custom legend items with dynamic count
                const legendItems = customizeLegend(category, metadata, currentLegendCount);

                // Add items to legend
                legendItems.forEach((item) => {
                  const legendItem = document.createElement("div");
                  legendItem.className = "d-flex align-items-center mb-2";

                  // Create HTML structure for each legend item
                  let html = `
                    <div class="legend-color" style="background-color: ${item.color};"></div>
                    <div>
                      <span class="fw-bold">${item.label}</span>
                  `;

                  // Add description if available
                  if (item.description) {
                    html += `<span class="ms-2 text-muted fst-italic small">${item.description}</span>`;
                  }

                  html += `</div>`;
                  legendItem.innerHTML = html;
                  legendContent.appendChild(legendItem);
                });

                // Add category and metadata to legend
                const categoryItem = document.createElement("div");
                categoryItem.className = "fw-bold mt-3";
                categoryItem.textContent = `Category: ${category}`;
                legendContent.appendChild(categoryItem);

                if (metadata && metadata.description) {
                  const descriptionItem = document.createElement("div");
                  descriptionItem.className = "small text-muted mt-1";
                  descriptionItem.textContent = metadata.description;
                  legendContent.appendChild(descriptionItem);
                }

                // Add legend count information
                const countItem = document.createElement("div");
                countItem.className = "small text-muted mt-1";
                countItem.textContent = `Legend items: ${legendItems.length}`;
                legendContent.appendChild(countItem);

                // Update legend title
                document.querySelector(".legend-title").textContent = `${category} Legend`;
              }

              // Update legend with color scale (fallback)
              function updateLegend(category) {
                const legendContent = document.getElementById("legend-content");
                legendContent.innerHTML = "";

                // Generate color scale based on selected category and count
                const colors = getColorScaleForCategory(category, currentLegendCount);

                // Add items to legend
                colors.forEach((color, index) => {
                  const value = index * 25; // Example value range
                  const legendItem = document.createElement("div");
                  legendItem.className = "d-flex align-items-center mb-2";
                  legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${color};"></div>
                    <div>${value} - ${value + 25}</div>
                  `;
                  legendContent.appendChild(legendItem);
                });

                // Add category to legend
                const categoryItem = document.createElement("div");
                categoryItem.className = "fw-bold mt-3";
                categoryItem.textContent = `Category: ${category}`;
                legendContent.appendChild(categoryItem);

                // Adjust legend title based on category
                document.querySelector(
                  ".legend-title"
                ).textContent = `${category} Legend`;
              }

              // Get color scale based on category and count
              function getColorScaleForCategory(category, count = 5) {
                // Generate a color gradient with the desired number of steps
                let baseColors;

                // Different color scales for different categories
                switch (category) {
                  case "Rainfall":
                    baseColors = ["#d4f1f9", "#2980b9"];
                    break;
                  case "Temperature":
                    baseColors = ["#f9e79f", "#a93226"];
                    break;
                  case "Population":
                    baseColors = ["#d5f5e3", "#145a32"];
                    break;
                  case "Vegetation":
                    baseColors = ["#fcf3cf", "#145a32"];
                    break;
                  case "Air Quality":
                    baseColors = ["#ebf5fb", "#21618c"];
                    break;
                  case "Water Resources":
                    baseColors = ["#eafaf1", "#186a3b"];
                    break;
                  case "Soil Health":
                    baseColors = ["#fef9e7", "#b7950b"];
                    break;
                  case "Land Use":
                    baseColors = ["#f4ecf7", "#6c3483"];
                    break;
                  default:
                    // Default blue scale for unknown categories
                    baseColors = ["#d4e6f1", "#154360"];
                }

                // Generate an array of colors with the requested count
                return interpolateColors(baseColors[0], baseColors[1], count);
              }

              // Helper function to interpolate between colors
              function interpolateColors(startColor, endColor, steps) {
                // Parse hex colors to RGB
                const start = {
                  r: parseInt(startColor.slice(1, 3), 16),
                  g: parseInt(startColor.slice(3, 5), 16),
                  b: parseInt(startColor.slice(5, 7), 16)
                };

                const end = {
                  r: parseInt(endColor.slice(1, 3), 16),
                  g: parseInt(endColor.slice(3, 5), 16),
                  b: parseInt(endColor.slice(5, 7), 16)
                };

                // Calculate step size for each color channel
                const stepR = (end.r - start.r) / (steps - 1);
                const stepG = (end.g - start.g) / (steps - 1);
                const stepB = (end.b - start.b) / (steps - 1);

                // Generate the color array
                const colorArray = [];
                for (let i = 0; i < steps; i++) {
                  const r = Math.round(start.r + (stepR * i));
                  const g = Math.round(start.g + (stepG * i));
                  const b = Math.round(start.b + (stepB * i));
                  colorArray.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
                }

                return colorArray;
              }

              // Get legend descriptions based on category (optional additional context)
              function getLegendDescriptions(category, count = 5) {
                let baseDescriptions = [];

                switch (category) {
                  case "Rainfall":
                    baseDescriptions = ["Very Dry", "Dry", "Moderate", "Wet", "Very Wet"];
                    break;
                  case "Temperature":
                    baseDescriptions = ["Very Cold", "Cold", "Moderate", "Hot", "Very Hot"];
                    break;
                  case "Population":
                    baseDescriptions = ["Very Low", "Low", "Medium", "High", "Very High"];
                    break;
                  case "Vegetation":
                    baseDescriptions = ["Barren", "Sparse", "Moderate", "Dense", "Very Dense"];
                    break;
                  case "Air Quality":
                    baseDescriptions = ["Excellent", "Good", "Moderate", "Poor", "Very Poor"];
                    break;
                  case "Water Resources":
                    baseDescriptions = ["Very Limited", "Limited", "Adequate", "Abundant", "Plentiful"];
                    break;
                  case "Soil Health":
                    baseDescriptions = ["Very Poor", "Poor", "Moderate", "Good", "Excellent"];
                    break;
                  case "Land Use":
                    baseDescriptions = ["Urban", "Agricultural", "Forest", "Water", "Other"];
                    break;
                  default:
                    return Array(count).fill("");
                }

                // If the requested count matches the base descriptions, return them directly
                if (count === baseDescriptions.length) {
                  return baseDescriptions;
                }

                // Otherwise, adjust to the requested count
                if (count < baseDescriptions.length) {
                  // Use a subset of descriptions
                  const step = Math.floor(baseDescriptions.length / count);
                  const result = [];
                  for (let i = 0; i < count; i++) {
                    const index = Math.min(i * step, baseDescriptions.length - 1);
                    result.push(baseDescriptions[index]);
                  }
                  return result;
                } else {
                  // Need to expand - generate intermediate descriptions
                  const result = [];
                  const step = (baseDescriptions.length - 1) / (count - 1);

                  for (let i = 0; i < count; i++) {
                    const index = Math.min(Math.round(i * step), baseDescriptions.length - 1);
                    result.push(baseDescriptions[index]);
                  }
                  return result;
                }
              }

              // Customize legend with additional information
              function customizeLegend(category, metadata, count = 5) {
                // This function creates a legend with the requested number of items

                const colors = getColorScaleForCategory(category, count);
                const descriptions = getLegendDescriptions(category, count);
                let legendItems = [];

                // Example of category-specific customization
                if (category === "Land Use" && count <= 5) {
                  // Example of custom legend for Land Use with specific items
                  return [
                    { color: "#d7bde2", label: "Urban Areas", description: "Cities, towns, and industrial zones" },
                    { color: "#a569bd", label: "Agricultural Land", description: "Farmland and cultivated areas" },
                    { color: "#8e44ad", label: "Forest Cover", description: "Natural forests and woodlands" },
                    { color: "#6c3483", label: "Water Bodies", description: "Lakes, rivers, and reservoirs" },
                    { color: "#4a235a", label: "Other Land", description: "Uncategorized land types" }
                  ].slice(0, count);
                } else if (category === "Soil Health" && count <= 6) {
                  // Another example with 6 items
                  return [
                    { color: "#fef9e7", label: "Very Poor", description: "pH < 5.0" },
                    { color: "#f9e79f", label: "Poor", description: "pH 5.0-5.5" },
                    { color: "#f7dc6f", label: "Fair", description: "pH 5.5-6.0" },
                    { color: "#f4d03f", label: "Moderate", description: "pH 6.0-6.5" },
                    { color: "#f1c40f", label: "Good", description: "pH 6.5-7.0" },
                    { color: "#b7950b", label: "Excellent", description: "pH > 7.0" }
                  ].slice(0, count);
                }

                // For other categories, generate based on metadata if available
                if (metadata && metadata.min !== undefined && metadata.max !== undefined) {
                  const min = metadata.min;
                  const max = metadata.max;
                  const range = max - min;
                  const step = range / (count - 1);
                  const units = metadata.units || '';

                  for (let i = 0; i < count; i++) {
                    const rangeStart = Math.round((min + (i * step)) * 100) / 100;
                    const rangeEnd = i < count - 1 ? Math.round((min + ((i + 1) * step)) * 100) / 100 : max;

                    legendItems.push({
                      color: colors[i],
                      label: `${rangeStart} - ${rangeEnd} ${units}`,
                      description: descriptions[i] || ''
                    });
                  }
                } else {
                  // Fallback to evenly distributed ranges
                  const step = 100 / count;

                  for (let i = 0; i < count; i++) {
                    const value = i * step;
                    const nextValue = (i + 1) * step;

                    legendItems.push({
                      color: colors[i],
                      label: `${Math.round(value)} - ${Math.round(nextValue)}`,
                      description: descriptions[i] || ''
                    });
                  }
                }

                return legendItems;
              }

              // Get color for a raster value
              function getColorForValue(value, category, metadata, count = 5) {
                const colors = getColorScaleForCategory(category, count);

                if (metadata && metadata.min !== undefined && metadata.max !== undefined) {
                  // Use dynamic ranges if metadata is available
                  const min = metadata.min;
                  const max = metadata.max;
                  const range = max - min;
                  const normalizedValue = Math.min(1, Math.max(0, (value - min) / range));
                  const colorIndex = Math.min(colors.length - 1, Math.floor(normalizedValue * colors.length));
                  return colors[colorIndex];
                } else {
                  // Fallback to fixed ranges
                  const normalizedValue = Math.min(1, Math.max(0, value / 100));
                  const colorIndex = Math.min(colors.length - 1, Math.floor(normalizedValue * colors.length));
                  return colors[colorIndex];
                }
              }

              // Function to recreate the raster layer with current settings
              function rerenderRasterLayer() {
                // Make sure we have a georaster to work with
                if (!currentGeoRaster) {
                  showNotification("Error", "No raster data loaded to adjust", "error");
                  return;
                }

                // Remove current layer if it exists
                if (currentRasterLayer && map.hasLayer(currentRasterLayer)) {
                  map.removeLayer(currentRasterLayer);
                }

                // Calculate opacity value from slider (1-10 to 0.1-1.0)
                const opacity = currentOpacity / 10;

                // Create a new georaster layer with updated settings
                currentRasterLayer = new GeoRasterLayer({
                  georaster: currentGeoRaster,
                  opacity: opacity,
                  resolution: 256,
                  pixelValuesToColorFn: (values) => {
                    if (values[0] === currentGeoRaster.noDataValue) {
                      return null; // transparent for no data values
                    }

                    // Get color based on value using metadata and legend count
                    return getColorForValue(values[0], currentCategory, rasterMetadata, currentLegendCount);
                  },
                });

                // Add the layer to the map
                currentRasterLayer.addTo(map);

                // Update legend with new count
                updateDynamicLegend(currentCategory, rasterMetadata);

                // Update zoom if bounds are available
                if (currentRasterBounds && currentRasterBounds.isValid()) {
                  try {
                    map.fitBounds(currentRasterBounds, {
                      padding: [20, 20],
                      maxZoom: currentZoomLevel,
                      animate: true,
                    });
                  } catch (error) {
                    console.error("Error during fitBounds:", error);
                  }
                }

                // Show success notification
                showNotification(
                  "Settings Applied",
                  `Updated raster display with ${currentLegendCount} legend items`,
                  "success"
                );
              }

              // Create pulse effect for new raster data
              function createPulseEffect() {
                const pulseContainer = document.createElement("div");
                pulseContainer.className =
                  "position-absolute top-50 start-50 translate-middle";
                pulseContainer.style.zIndex = "800";

                const pulse = document.createElement("div");
                pulse.className = "rounded-circle";
                pulse.style.width = "300px";
                pulse.style.height = "300px";
                pulse.style.background = "rgba(52, 152, 219, 0.3)";
                pulse.style.animation = "pulse 1.5s ease-out";
                pulse.style.position = "absolute";
                pulse.style.opacity = "0";

                pulseContainer.appendChild(pulse);
                document.querySelector(".map-container").appendChild(pulseContainer);

                // Remove after animation
                setTimeout(() => {
                  if (
                    document.querySelector(".map-container").contains(pulseContainer)
                  ) {
                    document
                      .querySelector(".map-container")
                      .removeChild(pulseContainer);
                  }
                }, 1500);
              }

              // Function to fetch categories from the backend
              async function fetchCategories() {
                loader.classList.remove("d-none");
                const categoryWrapper = document.getElementById("category-wrapper");

                try {
                  const response = await fetch("/visuall/categories/");

                  if (!response.ok) {
                    throw new Error(`API responded with status ${response.status}`);
                  }

                  // Parse the JSON response
                  const data = await response.json();
                  console.log("Backend categories response:", data);

                  // Clear existing options
                  categoryDropdown.innerHTML = "";

                  // Add default option
                  const defaultOption = document.createElement("option");
                  defaultOption.value = "";
                  defaultOption.textContent = "Select a category";
                  defaultOption.disabled = true;
                  defaultOption.selected = true;
                  categoryDropdown.appendChild(defaultOption);

                  // Add categories from API response
                  data.forEach((category) => {
                    const option = document.createElement("option");
                    option.value = category;
                    option.textContent = category;
                    categoryDropdown.appendChild(option);
                  });

                  // Show indicator
                  document.getElementById("category-indicator").style.display =
                    "flex";

                  // Hide loader
                  loader.classList.add("d-none");

                  // Show success notification
                  showNotification(
                    "Success",
                    "Categories loaded successfully",
                    "success"
                  );
                } catch (error) {
                  console.error("Error fetching categories:", error);

                  // Hide loader
                  loader.classList.add("d-none");

                  // Show error notification
                  showNotification(
                    "Error",
                    `Failed to load categories: ${error.message}`,
                    "error"
                  );

                  // Add some real categories for backup
                  const realCategories = [
                    "Rainfall",
                    "Temperature",
                    "Population",
                    "Vegetation",
                    "Air Quality",
                    "Water Resources",
                    "Soil Health",
                    "Land Use",
                  ];

                  // Clear existing options
                  categoryDropdown.innerHTML = "";

                  // Add default option
                  const defaultOption = document.createElement("option");
                  defaultOption.value = "";
                  defaultOption.textContent = "Select a category";
                  defaultOption.disabled = true;
                  defaultOption.selected = true;
                  categoryDropdown.appendChild(defaultOption);

                  // Add backup categories
                  realCategories.forEach((category) => {
                    const option = document.createElement("option");
                    option.value = category;
                    option.textContent = category;
                    categoryDropdown.appendChild(option);
                  });

                  // Show indicator with warning
                  const indicator = document.getElementById("category-indicator");
                  indicator.style.display = "flex";
                  indicator.innerHTML =
                    '<i class="fas fa-exclamation-triangle"></i> Using backup categories';
                  indicator.className = "text-warning mt-1 small";
                }
              }

              // Function to fetch raster files for a selected category
              async function fetchRasterFiles(category) {
                // Show loading state
                const rasterWrapper = document.getElementById("raster-wrapper");
                rasterDropdown.disabled = true;

                // Show loader
                loader.classList.remove("d-none");

                // Show data tooltip
                dataTooltip.textContent = `Loading raster files for ${category}...`;
                dataTooltip.classList.add("show");

                try {
                  // API endpoint for fetching raster files
                  const response = await fetch(`/visuall/raster_data/${category}/`);

                  if (!response.ok) {
                    throw new Error(`API responded with status ${response.status}`);
                  }

                  // Parse the response
                  const data = await response.json();
                  console.log("Raster files response:", data);

                  // Enable the dropdown
                  rasterDropdown.disabled = false;
                  rasterWrapper.classList.remove("disabled-section");

                  // Clear existing options
                  rasterDropdown.innerHTML = "";

                  // Add default option
                  const defaultOption = document.createElement("option");
                  defaultOption.value = "";
                  defaultOption.textContent = "Select a raster file";
                  defaultOption.disabled = true;
                  defaultOption.selected = true;
                  rasterDropdown.appendChild(defaultOption);

                  // Add raster files from API response
                  data.forEach((file) => {
                    const option = document.createElement("option");
                    option.value = file.id || file;
                    option.textContent = file.name || file;
                    rasterDropdown.appendChild(option);
                  });

                  // Update indicator
                  const indicator = document.getElementById("raster-indicator");
                  indicator.style.display = "flex";
                  document.getElementById("raster-count").textContent = data.length;

                  // Hide loading states
                  loader.classList.add("d-none");
                  dataTooltip.classList.remove("show");

                  // Show success notification
                  showNotification(
                    "Files Available",
                    `${data.length} raster files found for ${category}`,
                    "success"
                  );
                } catch (error) {
                  console.error("Error fetching raster files:", error);

                  // Hide loading states
                  loader.classList.add("d-none");
                  dataTooltip.classList.remove("show");

                  // Show error notification
                  showNotification(
                    "Error",
                    `Failed to load raster files: ${error.message}. Please contact support.`,
                    "error"
                  );

                  // Keep the dropdown disabled when no files are available
                  rasterWrapper.classList.add("disabled-section");
                  rasterDropdown.disabled = true;
                }
              }

              // Function to fetch metadata for a raster file
              async function fetchRasterMetadata(category, filename) {
                try {
                  // API endpoint for fetching metadata
                  const metadataUrl = `/visuall/metadata/${category}/${filename}/`;
                  const response = await fetch(metadataUrl);

                  if (!response.ok) {
                    console.warn(`Could not fetch metadata: ${response.status}`);
                    return null;
                  }

                  const metadata = await response.json();
                  console.log("Metadata response:", metadata);
                  return metadata;
                } catch (error) {
                  console.warn("Error fetching metadata:", error);
                  return null;
                }
              }

            // Function to fetch and display raster data
            async function fetchRasterData(category, filename) {
              // Show loader
              loader.classList.remove("d-none");

              // Show data tooltip
              dataTooltip.textContent = `Loading ${filename}...`;
              dataTooltip.classList.add("show");

              // Update UI
              document.getElementById(
                "current-layer-display"
              ).textContent = `${category}: ${filename}`;

              try {
                // Try to fetch metadata first for enhanced legend
                rasterMetadata = await fetchRasterMetadata(category, filename);

                // API endpoint for fetching raster data
                const apiUrl = `/visuall/raster_file/${category}/${filename}/`;
                const response = await fetch(apiUrl);

                if (!response.ok) {
                  throw new Error(`API responded with status ${response.status}`);
                }

                // Get the raw raster data as an array buffer
                const arrayBuffer = await response.arrayBuffer();

                // Parse the georaster from the array buffer
                parseGeoraster(arrayBuffer)
                  .then((georaster) => {
                    // Store the georaster for reuse
                    currentGeoRaster = georaster;

                    // Remove existing raster layer if any
                    if (currentRasterLayer) {
                      map.removeLayer(currentRasterLayer);
                    }

                    // If metadata wasn't fetched separately, extract it from georaster
                    if (!rasterMetadata) {
                      rasterMetadata = {
                        min: georaster.mins[0],
                        max: georaster.maxs[0],
                        noData: georaster.noDataValue,
                        description: `Raster resolution: ${georaster.pixelWidth}x${georaster.pixelHeight}`,
                        units: getUnitsForCategory(category)
                      };
                    }

                    // Calculate opacity value from slider (1-10 to 0.1-1.0)
                    const opacity = currentOpacity / 10;

                    // Create a new georaster layer with enhanced color function
                    currentRasterLayer = new GeoRasterLayer({
                      georaster: georaster,
                      opacity: opacity,
                      resolution: 256,
                      pixelValuesToColorFn: (values) => {
                        if (values[0] === georaster.noDataValue) {
                          return null; // transparent for no data values
                        }

                        // Get color based on value using metadata and legend count
                        return getColorForValue(values[0], category, rasterMetadata, currentLegendCount);
                      },
                    });

                    // Store bounds for reuse when changing basemaps
                    if (georaster.projection && georaster.projection.bbox) {
                      console.log(
                        "Original georaster bbox:",
                        georaster.projection.bbox
                      );

                      // Create a proper Leaflet bounds object - FIXED ORDER OF COORDINATES
                      currentRasterBounds = L.latLngBounds(
                        [
                          georaster.projection.bbox[1],  // lat1
                          georaster.projection.bbox[0],  // lng1
                        ],
                        [
                          georaster.projection.bbox[3],  // lat2
                          georaster.projection.bbox[2]   // lng2
                        ]
                      );

                      console.log(
                        "Created bounds object:",
                        currentRasterBounds.toString()
                      );
                    }

                    // Add the layer to the map
                    currentRasterLayer.addTo(map);

                    // Update state variables
                    currentCategory = category;
                    currentRasterFile = filename;

                    // Update legend with dynamic data and current legend count
                    updateDynamicLegend(category, rasterMetadata);

                    // IMPROVED ZOOMING FUNCTION - gives the layer more time to load
                    setTimeout(() => {
                      zoomToRasterBounds();
                    }, 500); // Increased timeout from 100ms to 500ms

                    // Hide data tooltip
                    dataTooltip.classList.remove("show");

                    // Hide loader
                    loader.classList.add("d-none");

                    // Show success notification
                    showNotification(
                      "Success",
                      `Raster data for ${filename} loaded successfully`,
                      "success"
                    );

                    // Create pulse effect
                    createPulseEffect();
                  })
                  .catch((error) => {
                    console.error("Error parsing georaster:", error);

                    // Hide loader
                    loader.classList.add("d-none");
                    dataTooltip.classList.remove("show");

                    // Show error notification
                    showNotification(
                      "Error",
                      `Could not parse raster data: ${error.message}. Please try another file.`,
                      "error"
                    );
                  });
              } catch (error) {
                console.error("Error fetching raster data:", error);

                // Hide loader
                loader.classList.add("d-none");

                // Hide data tooltip
                dataTooltip.classList.remove("show");

                // Show error notification
                showNotification(
                  "Error",
                  `Failed to load raster data: ${error.message}. Please try another file.`,
                  "error"
                );
              }
            }

            // MODIFIED FUNCTION FOR ZOOMING WITH INCREASED ZOOM LEVELS
            function zoomToRasterBounds() {
              if (currentRasterBounds && currentRasterBounds.isValid()) {
                console.log("Zooming to bounds:", currentRasterBounds.toString());

                try {
                  // Check if the bounds are too small - sometimes GeoJSON files have very tight bounds
                  if (map.getBoundsZoom(currentRasterBounds) > 18) {
                    console.log("Bounds are too tight, padding more");
                    map.fitBounds(currentRasterBounds, {
                      padding: [100, 100], // Much larger padding for small areas
                      maxZoom: Math.min(16, currentZoomLevel + 2), // INCREASED: was 14, now 16 or current+2
                      animate: true,
                      duration: 1.5 // Longer animation
                    });
                  } else {
                    // Normal zoom for appropriately sized bounds - INCREASED ZOOM
                    map.fitBounds(currentRasterBounds, {
                      padding: [50, 50],
                      maxZoom: currentZoomLevel + 2, // INCREASED: added +2 to zoom in more
                      animate: true,
                      duration: 1
                    });
                  }
                  console.log("Zoom completed successfully with increased zoom level");
                } catch (error) {
                  console.error("Error during fitBounds:", error);

                  // Try manual approach as backup - WITH INCREASED ZOOM
                  try {
                    // Get the center of the bounds and use setView instead
                    const center = currentRasterBounds.getCenter();
                    const zoom = Math.min(currentZoomLevel + 3, 12); // INCREASED: was min(currentZoomLevel, 10)
                    console.log("Using setView fallback with increased zoom:", center, zoom);
                    map.setView(center, zoom, { animate: true });
                    console.log("setView fallback completed");
                  } catch (secondError) {
                    console.error("Even setView failed:", secondError);
                    // Final fallback to a default view of India - INCREASED ZOOM
                    map.setView([20.5937, 78.9629], 6); // INCREASED: was 5, now 6
                  }
                }
              } else {
                console.warn("No valid bounds available for zoom");
                // Try to extract bounds from the currentRasterLayer
                try {
                  if (currentRasterLayer && typeof currentRasterLayer.getBounds === 'function') {
                    const layerBounds = currentRasterLayer.getBounds();
                    if (layerBounds && layerBounds.isValid()) {
                      console.log("Using layer bounds:", layerBounds.toString());
                      map.fitBounds(layerBounds, {
                        padding: [50, 50],
                        maxZoom: currentZoomLevel + 2, // INCREASED: added +2 to zoom in more
                        animate: true
                      });
                      return; // Exit if successful
                    }
                  }
                } catch (e) {
                  console.warn("Couldn't get bounds from layer:", e);
                }

                // Fallback to a default view of India - INCREASED ZOOM
                map.setView([20.5937, 78.9629], 6); // INCREASED: was 5, now 6
              }
            }
              // Helper function to get units for a category
              function getUnitsForCategory(category) {
                switch (category) {
                  case "Rainfall":
                    return "mm";
                  case "Temperature":
                    return "°C";
                  case "Population":
                    return "people/km²";
                  case "Vegetation":
                    return "NDVI";
                  case "Air Quality":
                    return "AQI";
                  case "Water Resources":
                    return "km³";
                  case "Soil Health":
                    return "index";
                  case "Land Use":
                    return "category";
                  default:
                    return "";
                }
              }

              // Toggle UI elements event listeners
              compassToggle.addEventListener("change", function () {
                document.getElementById("compass").style.display = this.checked
                  ? "flex"
                  : "none";
                document.getElementById("rotation-control").style.display = this
                  .checked
                  ? "block"
                  : "none";
              });

              legendToggle.addEventListener("change", function () {
                document.getElementById("map-legend").style.display = this.checked
                  ? "block"
                  : "none";
              });

              gridToggle.addEventListener("change", function () {
                if (this.checked) {
                  addCoordinateGrid();
                } else {
                  gridLines.forEach((line) => {
                    if (map.hasLayer(line)) {
                      map.removeLayer(line);
                    }
                  });
                  gridLines = [];
                }
              });

              // Category dropdown change event
              categoryDropdown.addEventListener("change", function (e) {
                const category = e.target.value;
                if (category) {
                  currentCategory = category;
                  fetchRasterFiles(category);

                  // Reset raster dropdown
                  rasterDropdown.innerHTML =
                    '<option value="" disabled selected>Loading raster files...</option>';

                  // Show notification
                  showNotification(
                    "Category Selected",
                    `Category changed to ${category}`,
                    "info"
                  );
                }
              });

              // Raster file dropdown change event
              rasterDropdown.addEventListener("change", function (e) {
                const filename = e.target.value;
                if (filename && currentCategory) {
                  fetchRasterData(currentCategory, filename);
                }
              });

              // Slider event listeners
              opacitySlider.addEventListener("input", function (e) {
                const value = e.target.value;
                opacityValue.textContent = value;
                currentOpacity = value;
              });

              legendCountSlider.addEventListener("input", function (e) {
                const value = e.target.value;
                legendCountValue.textContent = value;
                currentLegendCount = parseInt(value);
              });

              zoomLevelSlider.addEventListener("input", function (e) {
                const value = e.target.value;
                zoomLevelValue.textContent = value;
                currentZoomLevel = parseInt(value);
              });

              // Apply settings button event listener
              applySettingsBtn.addEventListener("click", function () {
                if (currentGeoRaster) {
                  rerenderRasterLayer();
                } else {
                  showNotification("Warning", "Load raster data first before applying settings", "warning");
                }
              });

              // Handle basemap dropdown items (updated for Bootstrap dropdown)
              document
                .querySelectorAll("#basemap-dropdown .dropdown-item")
                .forEach((item) => {
                  item.addEventListener("click", function (e) {
                    e.preventDefault();
                    const basemapType = this.getAttribute("data-basemap");
                    changeBasemap(basemapType);
                  });
                });

              // Handle drawing tools dropdown items (updated for Bootstrap dropdown)
              document
                .querySelectorAll("#drawing-dropdown .dropdown-item")
                .forEach((item) => {
                  item.addEventListener("click", function (e) {
                    e.preventDefault();
                    const toolType = this.getAttribute("data-tool");

                    switch (toolType) {
                      case "point":
                        new L.Draw.Marker(map).enable();
                        showNotification(
                          "Drawing Tool",
                          "Point tool activated",
                          "info"
                        );
                        break;
                      case "line":
                        new L.Draw.Polyline(map).enable();
                        showNotification(
                          "Drawing Tool",
                          "Line tool activated",
                          "info"
                        );
                        break;
                      case "polygon":
                        new L.Draw.Polygon(map).enable();
                        showNotification(
                          "Drawing Tool",
                          "Polygon tool activated",
                          "info"
                        );
                        break;
                      case "measure":
                        new L.Draw.Polyline(map, {
                          shapeOptions: {
                            color: "#ff7800",
                            weight: 3,
                          },
                        }).enable();
                        showNotification(
                          "Measurement Tool",
                          "Draw a line to measure distance",
                          "info"
                        );
                        break;
                      case "clear":
                        drawnItems.clearLayers();
                        showNotification(
                          "Cleared",
                          "All drawings have been cleared",
                          "info"
                        );
                        break;
                    }
                  });
                });

              // Handle analysis tools (updated for Bootstrap dropdown)
              document
                .querySelectorAll("#analysis-dropdown .dropdown-item")
                .forEach((item) => {
                  item.addEventListener("click", function (e) {
                    e.preventDefault();
                    const analysisType = this.getAttribute("data-analysis");

                    // Show notification for demo
                    showNotification(
                      "Analysis Tool",
                      `${
                        analysisType.charAt(0).toUpperCase() + analysisType.slice(1)
                      } analysis tool selected`,
                      "info"
                    );
                  });
                });

              // Toggle sidebar
              document
                .getElementById("toggle-sidebar")
                .addEventListener("click", function () {
                  const sidebar = document.getElementById("sidebar");
                  const toggleBtn = document.getElementById("toggle-sidebar");
                  const toggleIcon = document.getElementById("toggle-icon");

                  sidebar.classList.toggle("collapsed");
                  toggleBtn.classList.toggle("collapsed");

                  if (sidebar.classList.contains("collapsed")) {
                    toggleIcon.className = "fas fa-chevron-right";
                  } else {
                    toggleIcon.className = "fas fa-chevron-left";
                  }
                });

              // Export button - initialize Bootstrap modal
              document
                .getElementById("export-btn")
                .addEventListener("click", function () {
                  const exportModal = new bootstrap.Modal(
                    document.getElementById("exportModal")
                  );
                  exportModal.show();
                });

              // Handle the export confirmation
              document
                .getElementById("confirmExport")
                .addEventListener("click", function () {
                  // Show processing message
                  showNotification(
                    "Processing",
                    "Preparing export, please wait...",
                    "info"
                  );

                  // Close the modal
                  const exportModal = bootstrap.Modal.getInstance(
                    document.getElementById("exportModal")
                  );
                  exportModal.hide();

                  // Get export options
                  const mapTitle = document.getElementById("exportTitle").value || "India GIS Raster Map";
                  const layout = document.getElementById("exportLayout").value;
                  const includeLegend = document.getElementById("exportLegend").checked;
                  const includeCoordinates = document.getElementById("exportCoordinates").checked;
                  const includeVectors = document.getElementById("exportVectors").checked;

                  // Capture the actual visible map directly
                  try {
                    // Wait a moment to ensure UI updates are complete
                    setTimeout(function() {
                      // Directly capture the existing map element
                      const mapElement = document.getElementById('map');

                      html2canvas(mapElement, {
                        useCORS: true,
                        allowTaint: true,
                        logging: false,
                        backgroundColor: null
                      }).then(function(mapCanvas) {
                        // Now create the full export image with the captured map

                        // Create canvas for the full export
                        const exportCanvas = document.createElement('canvas');
                        const ctx = exportCanvas.getContext('2d');

                        // Set size based on layout
                        let width, height;
                        if (layout.includes('landscape')) {
                          width = 1200;
                          height = 850;
                        } else {
                          width = 850;
                          height = 1200;
                        }

                        exportCanvas.width = width;
                        exportCanvas.height = height;

                        // Draw white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, width, height);

                        // Draw title
                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(mapTitle, width/2, 40);


                        // Calculate map position and size
                        const legendHeight = includeLegend ? 150 : 0;
                        const mapWidth = width - 80;
                        const mapHeight = height - 140 - legendHeight;
                        const mapX = 40;
                        const mapY = 70;

                        // Draw map from the canvas
                        ctx.drawImage(mapCanvas, mapX, mapY, mapWidth, mapHeight);

                        // Draw border around map
                        ctx.strokeStyle = '#ccc';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(mapX, mapY, mapWidth, mapHeight);

                        // Add metadata below map
                        let metadataY = mapY + mapHeight + 20;
                        if (currentCategory && currentRasterFile) {
                          ctx.fillStyle = '#333';
                          ctx.font = '14px Arial';
                          ctx.textAlign = 'center';
                          ctx.fillText(`Category: ${currentCategory} | Dataset: ${currentRasterFile}`, width/2, metadataY);
                          metadataY += 20;
                        }

                        // Add legend if requested
                        if (includeLegend && currentCategory) {
                          const legendY = metadataY + 10;
                          const legendX = 50;

                          // Draw legend title
                          ctx.fillStyle = '#333';
                          ctx.font = 'bold 16px Arial';
                          ctx.textAlign = 'left';
                          ctx.fillText('Legend', legendX, legendY);

                          // Get dynamic legend items using the customizeLegend function
                          const legendItems = customizeLegend(currentCategory, rasterMetadata);
                          const rowHeight = 30; // Increased height for descriptions
                          const colorSize = 20;

                          // Calculate total legend height to adjust positioning
                          const totalLegendHeight = rowHeight * legendItems.length + 30;

                          ctx.font = '14px Arial';

                          // Draw each legend item with label and description
                          legendItems.forEach((item, index) => {
                            const y = legendY + 25 + (index * rowHeight);

                            // Draw color box
                            ctx.fillStyle = item.color;
                            ctx.fillRect(legendX, y, colorSize, colorSize);
                            ctx.strokeStyle = '#666';
                            ctx.strokeRect(legendX, y, colorSize, colorSize);

                            // Draw label
                            ctx.fillStyle = '#333';
                            ctx.textAlign = 'left';
                            ctx.font = 'bold 14px Arial';
                            ctx.fillText(item.label, legendX + colorSize + 10, y + 14);

                            // Draw description if available
                            if (item.description) {
                              ctx.font = 'italic 12px Arial';
                              ctx.fillStyle = '#666';
                              ctx.fillText(item.description, legendX + colorSize + 10 + ctx.measureText(item.label).width + 15, y + 14);
                            }
                          });
                        }

                        // Draw footer
                        ctx.fillStyle = '#666';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        const now = new Date();
                        const dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString();
                        ctx.fillText(`Generated on: ${dateStr} | India GIS Raster Data Viewer`, width/2, height - 20);

                        // Convert to image and download
                        const imgData = exportCanvas.toDataURL('image/png');
                        const link = document.createElement('a');
                        link.download = mapTitle.replace(/\s+/g, '_') + '.png';
                        link.href = imgData;
                        link.click();

                        // Show success notification
                        showNotification(
                          "Export Complete",
                          `Map has been exported as "${link.download}"`,
                          "success"
                        );
                      }).catch(function(error) {
                        console.error("Error capturing map:", error);
                        showNotification(
                          "Export Failed",
                          "Could not capture map: " + error.message,
                          "error"
                        );

                        // Offer simple placeholder export
                        offerPlaceholderExport();
                      });
                    }, 500); // Small delay to ensure UI is updated
                  } catch (error) {
                    console.error("Error in export process:", error);
                    showNotification(
                      "Export Failed",
                      "Error in export process: " + error.message,
                      "error"
                    );

                    // Offer placeholder export
                    offerPlaceholderExport();
                  }

                  // Fallback function to create a placeholder export
                  function offerPlaceholderExport() {
                    try {
                      // Create a canvas
                      const canvas = document.createElement('canvas');
                      const ctx = canvas.getContext('2d');

                      // Set canvas size
                      canvas.width = 800;
                      canvas.height = 600;

                      // Draw background
                      ctx.fillStyle = 'white';
                      ctx.fillRect(0, 0, canvas.width, canvas.height);

                      // Draw header
                      ctx.fillStyle = '#3498db';
                      ctx.fillRect(0, 0, canvas.width, 50);
                      ctx.fillStyle = 'white';
                      ctx.font = 'bold 24px Arial';
                      ctx.textAlign = 'center';
                      ctx.fillText(mapTitle, canvas.width/2, 35);

                      // Draw map area placeholder
                      ctx.fillStyle = '#f8f9fa';
                      ctx.fillRect(50, 70, canvas.width - 100, 350);
                      ctx.strokeStyle = '#ddd';
                      ctx.lineWidth = 1;
                      ctx.strokeRect(50, 70, canvas.width - 100, 350);

                      // Draw placeholder text
                      ctx.fillStyle = '#777';
                      ctx.font = '16px Arial';
                      ctx.fillText('Map capture failed - Please use a screenshot tool', canvas.width/2, 200);
                      ctx.fillText('Current view: ' + (currentCategory || 'No data'), canvas.width/2, 230);

                      // Draw legend placeholder if requested
                      if (includeLegend) {
                        ctx.fillStyle = '#f8f9fa';
                        ctx.fillRect(50, 440, canvas.width - 100, 120);
                        ctx.strokeStyle = '#ddd';
                        ctx.strokeRect(50, 440, canvas.width - 100, 120);

                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText('Legend (placeholder)', 70, 465);

                        if (currentCategory) {
                          ctx.font = '14px Arial';
                          ctx.fillText(`Category: ${currentCategory}`, 70, 490);
                        }
                      }

                      // Draw footer
                      ctx.fillStyle = '#eee';
                      ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
                      ctx.fillStyle = '#666';
                      ctx.font = '12px Arial';
                      ctx.textAlign = 'center';
                      const now = new Date();
                      const dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString();
                      ctx.fillText(`Generated on: ${dateStr} | India GIS Raster Data Viewer`, canvas.width/2, canvas.height - 15);

                      // Create download link
                      const link = document.createElement('a');
                      link.download = mapTitle.replace(/\s+/g, '_') + '_template.png';
                      link.href = canvas.toDataURL('image/png');
                      link.click();

                      // Show notification
                      showNotification(
                        "Template Exported",
                        "A map template was exported. Please use a screenshot tool to capture the actual map.",
                        "info"
                      );
                    } catch (error) {
                      console.error("Placeholder export failed:", error);
                      showNotification(
                        "Export Failed",
                        "Could not create export in any format. Please use a screenshot tool.",
                        "error"
                      );
                    }
                  }
                });

              // Map controls
              document
                .getElementById("zoom-in-btn")
                .addEventListener("click", function () {
                  map.zoomIn(1);
                  this.classList.add("active");
                  setTimeout(() => this.classList.remove("active"), 200);
                });

              document
                .getElementById("zoom-out-btn")
                .addEventListener("click", function () {
                  map.zoomOut(1);
                  this.classList.add("active");
                  setTimeout(() => this.classList.remove("active"), 200);
                });

              document
                .getElementById("home-btn")
                .addEventListener("click", function () {
                  map.setView(INDIA_CENTER, INDIA_ZOOM);
                  this.classList.add("active");
                  setTimeout(() => this.classList.remove("active"), 200);

                  // Show notification
                  showNotification("Map Reset", "Returned to default view", "info");
                });

              document
                .getElementById("locate-btn")
                .addEventListener("click", function () {
                  this.classList.add("active");
                  setTimeout(() => this.classList.remove("active"), 200);

                  showNotification("Location", "Finding your location...", "info");

                  // Use real geolocation
                  if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                      function (position) {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;

                        map.setView([lat, lng], 10);

                        // Add a marker
                        const locationMarker = L.marker([lat, lng], {
                          icon: L.divIcon({
                            className: "location-marker",
                            html: `<div style="width: 20px; height: 20px; background: rgba(52, 152, 219, 0.8); border: 2px solid white; border-radius: 50%; box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3), 0 0 8px rgba(0,0,0,0.3);"></div>`,
                            iconSize: [20, 20],
                            iconAnchor: [10, 10],
                          }),
                        }).addTo(map);

                        showNotification(
                          "Location Found",
                          "Your current location has been found",
                          "success"
                        );
                      },
                      function (error) {
                        console.error("Geolocation error:", error);
                        showNotification(
                          "Location Error",
                          "Could not access your location. Please check your browser settings.",
                          "error"
                        );
                      }
                    );
                  } else {
                    showNotification(
                      "Location Error",
                      "Geolocation is not supported by your browser",
                      "error"
                    );
                  }
                });

              document
                .getElementById("fullscreen-btn")
                .addEventListener("click", function () {
                  if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch((err) => {
                      showNotification(
                        "Error",
                        `Fullscreen failed: ${err.message}`,
                        "error"
                      );
                    });
                    this.innerHTML = '<i class="fas fa-compress"></i>';
                  } else {
                    if (document.exitFullscreen) {
                      document.exitFullscreen();
                      this.innerHTML = '<i class="fas fa-expand"></i>';
                    }
                  }
                });

              // Rotation control
              document
                .getElementById("rotation-control")
                .addEventListener("click", function () {
                  mapRotation = (mapRotation + 45) % 360;
                  document.querySelector(
                    ".map-container"
                  ).style.transform = `rotate(${mapRotation}deg)`;
                  document.querySelector(
                    ".compass-rose"
                  ).style.transform = `rotate(${-mapRotation}deg)`;
                });

              // Mouse position tracking
              map.on("mousemove", function (e) {
                document.getElementById(
                  "coordinates-display"
                ).textContent = `${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(
                  5
                )}`;

                // Update coordinate tooltip (UTM conversion is simplified for demo)
                const lat = e.latlng.lat.toFixed(5);
                const lng = e.latlng.lng.toFixed(5);
                const utmX = Math.floor(
                  parseFloat(lng) *
                    111320 *
                    Math.cos((parseFloat(lat) * Math.PI) / 180)
                );
                const utmY = Math.floor(parseFloat(lat) * 111320);

                document.getElementById(
                  "coordinates-tooltip"
                ).innerHTML = `Lat: ${lat}, Lng: ${lng}<br>
                <small>UTM: 43Q ${utmX} ${utmY}</small>`;
              });

              // Show detailed coordinates on mouse hover
              map.on("mouseover", function () {
                document.getElementById("coordinates-tooltip").style.display =
                  "block";
              });

              map.on("mouseout", function () {
                document.getElementById("coordinates-tooltip").style.display = "none";
              });

              // Handle drawing events
              map.on(L.Draw.Event.CREATED, function (event) {
                const layer = event.layer;
                drawnItems.addLayer(layer);

                // If it's a polygon, calculate area
                if (layer instanceof L.Polygon) {
                  const latlngs = layer.getLatLngs()[0];

                  // Calculate area (using simple formula for demo)
                  let area = 0;
                  for (let i = 0; i < latlngs.length; i++) {
                    const j = (i + 1) % latlngs.length;
                    area += latlngs[i].lng * latlngs[j].lat;
                    area -= latlngs[j].lng * latlngs[i].lat;
                  }
                  area = Math.abs(area) * 0.5 * 111.32 * 111.32; // Rough conversion to square km

                  layer
                    .bindPopup(`<strong>Area:</strong> ${area.toFixed(2)} sq km`)
                    .openPopup();
                }

                // If it's a polyline, calculate length
                if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                  const latlngs = layer.getLatLngs();
                  let length = 0;

                  for (let i = 0; i < latlngs.length - 1; i++) {
                    length += latlngs[i].distanceTo(latlngs[i + 1]);
                  }

                  layer
                    .bindPopup(
                      `<strong>Length:</strong> ${(length / 1000).toFixed(2)} km`
                    )
                    .openPopup();
                }

                // If it's a marker, show coordinates
                if (layer instanceof L.Marker) {
                  const latLng = layer.getLatLng();
                  layer
                    .bindPopup(
                      `<strong>Coordinates:</strong><br>Lat: ${latLng.lat.toFixed(
                        5
                      )}<br>Lng: ${latLng.lng.toFixed(5)}`
                    )
                    .openPopup();
                }

                // Show success notification
                showNotification(
                  "Drawing Complete",
                  "Your drawing has been added to the map",
                  "success"
                );
              });

              // Initialize with coordinate grid
              addCoordinateGrid();

              // Fetch categories when the page loads
              fetchCategories();

              // Mobile screen detection and adjustments
              function adjustForScreenSize() {
                if (window.innerWidth <= 768) {
                  const sidebar = document.getElementById("sidebar");
                  const toggleBtn = document.getElementById("toggle-sidebar");
                  sidebar.classList.add("collapsed");
                  toggleBtn.classList.add("collapsed");
                  document.getElementById("toggle-icon").className =
                    "fas fa-chevron-right";
                }
              }

              // Check screen size on load
              adjustForScreenSize();

              // Update when window is resized
              window.addEventListener("resize", adjustForScreenSize);
            });
    </script>
  </body>
</html>
